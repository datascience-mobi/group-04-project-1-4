---
title: "PCA and related plots -> Dmut"
author: "Elias Benjamin Farr"
date: "17 Mai 2019"
output: html_document
---
Objective of PCA:
  + For this dimension reduction process, we try to find similarity in the dataset.
  + Prinicipal Components describe the directions with the most varianc in data.
  
#Loading Data
```{r Load.Data}
allDepMapData = readRDS("path/to/your/directory/DepMap19Q1_allData.RDS")
BCCL_Numbers = which(allDepMapData$annotation[4]== "Breast Cancer") 
BCCL_Annotation = subset(allDepMapData$annotation, Primary.Disease == "Breast Cancer")
#see what we got
summary(BCCL_Annotation)
# copy expression matrix to new dataframes
df1 <- allDepMapData$expression
df2 <- allDepMapData$copynumber
df3 <- allDepMapData$kd.ceres
df4 <- allDepMapData$kd.prob
#change column names to numbers for easier handling
names(df1) <- c(1:544)
names(df2) <- c(1:544)
names(df3) <- c(1:544)
names(df4) <- c(1:544)
#extract BCCL as dataframe
BCCL_Expression <- as.data.frame( df1[, c(BCCL_Numbers)])
BCCl_Copynumber <- as.data.frame( df2[, c(BCCL_Numbers)])
BCCL_kd.ceres <- as.data.frame( df3[, c(BCCL_Numbers)])
BCCL_kd.prob <- as.data.frame( df4[, c(BCCL_Numbers)])
dim(BCCL_Expression)
dim(BCCl_Copynumber)
dim(BCCL_kd.ceres)
dim(BCCL_kd.prob)
#reorder rows alphabetically
BCCL_Expression <- BCCL_Expression[order(rownames(BCCL_Expression)), ]
BCCl_Copynumber <- BCCl_Copynumber[order(rownames(BCCl_Copynumber)), ]
BCCL_kd.ceres <- BCCL_kd.ceres[order(rownames(BCCL_kd.ceres)), ]
BCCL_kd.prob <- BCCL_kd.prob[order(rownames(BCCL_kd.prob)), ]
#subset Mutation matrix in BCCL
BCCL_Mutation <- allDepMapData$mutation[c(BCCL_Numbers)]

Patients_ID <- BCCL_Annotation[1] #get patients ID from annotation matrix
tPatients_ID <- t(Patients_ID) #transpose Patients_ID because it was a column and we want to insert it as row
rownameskdc <- rownames(BCCL_kd.ceres) # save old rownames
existingDF <- BCCL_kd.ceres  # define variables for BCCL_kd.ceres
r <- 1
newrow <- tPatients_ID
#defining a function we can use more often to insert rows
insertRow <- function(existingDF, newrow, r) { 
    existingDF[seq(r+1,nrow(existingDF)+1),] <- existingDF[seq(r,nrow(existingDF)),]
    existingDF[r,] <- newrow
    existingDF
}
BCCL_kd.ceres_ID <- insertRow(existingDF, newrow, r)
rownames(BCCL_kd.ceres_ID) <- c("Deep_ID", rownameskdc) # change rownames back 
BCCL_kd.ceres_ID[1:2, ]
#do the same with other 3 dataframes
rownamesex <- rownames(BCCL_Expression) #save rownames
existingDF <- BCCL_Expression  # define variables for BCCL_Erpression
r <- 1
newrow <- tPatients_ID
BCCL_Expression_ID <- insertRow(existingDF, newrow, r)
rownames(BCCL_Expression_ID) <- c("Deep_ID", rownamesex)
rownamescn <- rownames(BCCl_Copynumber) #save rownames
existingDF <- BCCl_Copynumber  # define variables for BCCL_Copynumber
r <- 1
newrow <- tPatients_ID
BCCl_Copynumber_ID <- insertRow(existingDF, newrow, r)
rownames(BCCl_Copynumber_ID) <- c("Deep_ID", rownamescn)
rownameskdp <- rownames(BCCL_kd.prob) #save rownames
existingDF <- BCCL_kd.prob  # define variables for BCCL_kd.prob
r <- 1
newrow <- tPatients_ID
BCCL_kd.prob_ID <- insertRow(existingDF, newrow, r)
rownames(BCCL_kd.prob_ID) <- c("Deep_ID", rownameskdp)
```

#kmeans for Expression data test
```{r kmeans}
BCCL_Expression_rmv = BCCL_Expression[rowSums(BCCL_Expression != 0) > 0, ]
BCCL_Expression_rmv_s = scale(BCCL_Expression)
km= kmeans(x = BCCL_Expression_rmv_s, centers = 2, nstart = 10)
table(km$cluster)
wss = sapply(2:10, function(k) {
    kmeans(x = BCCL_Expression_rmv_s, centers = k)$tot.withinss
})
plot(2:10, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares") # optimal number 4 clusters

km = kmeans(x = BCCL_Expression_rmv_s, centers = 4, nstart = 10)
table(km$cluster)

fviz_cluster(km, data=BCCL_Expression_rmv_s)

#trying to determine optimal cluster number with silhouette method- not yet functional 

s <- sapply(2:10, function(k) {
  kmeans(x=BCCL_Expression_rmv_s, centers = k);
  D = dist(BCCL_Expression_rmv_s);
  si = silhouette(km$cluster, D);
  si_sum = (summary(si, FUN = mean))
})
```

#generating kmeans input matrix
```{r kmeans ceres}
#loading required packages
install.packages("tidyverse")
install.packages("factoextra")
library(tidyverse)
library(cluster)
library(factoextra)

#Loading mutImpact matrix
pre_mutImpact <- BCCL_kd.ceres
colnames(pre_mutImpact)<-tPatients_ID
mutImpact <- matrix( , nrow = 17634, ncol = 28)
colnames(mutImpact)<-colnames(pre_mutImpact)
rownames(mutImpact)<-rownames(pre_mutImpact)
for (j in 1:ncol(pre_mutImpact)){
  lineID <- colnames(pre_mutImpact)[j] #select a column-name aka cell line
  for (i in 1:nrow(pre_mutImpact)){
    GOI <- rownames(pre_mutImpact)[i] #select a gene
    if (GOI %in% BCCL_Mutation[[lineID]]$Hugo_Symbol){
      mutImpact[i, j] <- pre_mutImpact[i, j]
    } else {
      mutImpact[i, j] <- NA
    }#replace CERES value with NA in case the gene is not mutated
  }
}

# selecting only genes mutated at least once and with Ceres >= 0

mutImpact_c = mutImpact[rowSums(is.na(mutImpact)) != ncol(mutImpact),]# remove all genes withall NA values
rownamesmutImpc = rownames(mutImpact_c)
mutImpact_c = cbind(rownamesmutImpc, mutImpact_c[,2:ncol(mutImpact_c)]) # insert new column with row names
dim(mutImpact_c) # check gene reduction 
rownameskdc2 = rownames(BCCL_kd.ceres)
BCCL_kd.ceres_2 = cbind(rownameskdc2, BCCL_kd.ceres[,2:ncol(BCCL_kd.ceres)]) # insert new column with row names
BCCL_kd.ceres_3 = BCCL_kd.ceres_2[BCCL_kd.ceres_2[,"rownameskdc2"] %in%  mutImpact_c[,"rownamesmutImpc"],] 
BCCL_kd.ceres_3 = BCCL_kd.ceres_3[,-c(1)]
BCCL_kd.ceres_3 = cbind(BCCL_kd.ceres_3, rowMeans(BCCL_kd.ceres_3)) #calculate rowmeans 
BCCL_kd.ceres_3 = BCCL_kd.ceres_3[rowMeans(BCCL_kd.ceres_3)<= 0,] # deletion of genes with CERES > 0
```

# k means clustering with new input matrix 
```{r kmeans clustering}

install.packages("tidyverse")
install.packages("factoextra")
library(tidyverse)
library(cluster)
library(factoextra)

km_CERES= kmeans(x = BCCL_kd.ceres_3, centers = 2, nstart = 10)
table(km_CERES$cluster)
wss = sapply(2:10, function(k) {
    kmeans(x = BCCL_kd.ceres_3, centers = k)$tot.withinss
})
plot(2:10, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares") # optimal number 4

km_CERES= kmeans(x = BCCL_kd.ceres_3, centers = 4, nstart = 10)
table(km_CERES$cluster)
fviz_cluster(km_CERES, data=BCCL_kd.ceres_3, labelsize = 6) # plotting clusters

km_CERES$cluster["ERBB2"]
km_CERES$cluster["ERBB2IP"]
km_CERES$cluster["MYCBP"]
km_CERES$cluster["PARP10"]
km_CERES$cluster["PIK3CA"] 

# all driver mutations in cluster 2 when centers = 2
# all driver mutations but ERBB2IP in cluster 3 when centers = 4 => hence ERBB2IP eliminate

data_cluster = km_CERES$cluster
rownames(data_cluster) = rownames(BCCL_kd.ceres_3)
data_clus_3 = BCCL_kd.ceres_3[data_cluster == 3,] #dataframe with all 1148 genes in same cluster as driver mutations 


#LABELING DRIVER MUTATIONS 
# CCND mutation not present in BCCL_kd.ceres_3 matrix but ERBB2, ERBB2IP, MYCBP, PARP10 and PIK3CA found. ERBB2IP however not in same cluster as other driver mutations 

drivermut =  c("ERBB2","MYCBP", "PARP10", "PIK3CA") # create vector with driver mutation names
data_clus_3e = data_clus_3
data_clus_3e["Driver mutation"] <- sapply(1:nrow(data_clus_3), function(j){
     if(rownames(data_clus_3e)[j] %in% drivermut){
         data_clus_3e[j,1] = "driver mutation"
     } else {
         data_clus_3e[j,1] = "no driver mutation"
     }
  }) # labeling driver mutations with "driver mutation" in data_clus_3e 
```

# Data visualisation of 4 driver mutations 
```{data visualisation}

barplot(data_clus_3[,"rowMeans(BCCL_kd.ceres_3)"], main="Gene cluster 3", xlab="CERES scores") 

GOI= BCCL_kd.ceres[c("ERBB2","MYCBP", "PARP10", "PIK3CA"),]
cellsamples = coln
CERES_boxplot = ggplot(GOI, aes(x = drivermut, y = GOI)) +
        geom_boxplot(fill = fill, colour = line, alpha = 0.7,
                     outlier.colour = "#1F3552", outlier.shape = 20) +
        scale_y_continuous(name = "CERES scores",
                           breaks = seq(0, 175, 25),
                           limits=c(0, 175)) +
        scale_x_discrete(name = "Driver mutations") +
        ggtitle("CERES scores of selected driver mutations")
CERES_boxplot
```

#PCA using BCCL_kd.ceres_3
```{r PCA BCCL_kd.ceres_3}
install.packages("ggfortify")
library(ggfortify)

tBCCL_kd.ceres = t(BCCL_kd.ceres_3[,-c(28)]) # transformation of BCCL_kd.ceres_3 matrix
CERES.pca = prcomp(tBCCL_kd.ceres, center = T, scale = T, rank = 2)  
summary(CERES.pca)

plot(CERES.pca, type = "l")  # Identify PCs with most variabilit SS
autoplot(CERES.pca, label = TRUE, label.size = 3) # need to add colour based on whether driver mutation or not

CERES.pca.loadings = CERES.pca$rotation # loadings PC1 and PC2
Sor.CERES.pca.load= -CERES.pca.loadings [order(CERES.pca.loadings[,1]),] #managed to order PC1 column according to size (PC2 not yet)
Sor.CERES.pca.load[1:200,] # first 200 genes do not contain driver mutations 
```


#Alternativ Code 

```{r code}
<<<<<<< HEAD
BCCL_kd.ceres_3 = BCCL_kd.ceres_2[BCCL_kd.ceres_2[,"rownameskdc2"] %in% mutImpact_c[,"rownamesmutImpc"],] # reduce BCCL_kd.ceres_2 matrix to genes mutated at least once

=======
#Alternative second try
BCCL_kd.ceres_an <- BCCL_kd.ceres #generate new data frame
colnames(BCCL_kd.ceres_an) <- rownames(BCCL_kd.ceres)

#generate new column containing information on mutation status
BCCL_kd.ceres_an$mutation <- sapply(1:nrow(BCCL_kd.ceres), function(j){
     if(rownames(BCCL_kd.ceres_an)[j] %in% rownames(mutImpact_c)){
         BCCL_kd.ceres_an[j,1] = "mutation"
     } else {
         BCCL_kd.ceres_an[j,1] = "no mutation"
     }
  })
BCCL_kd.ceres_an <- BCCL_kd.ceres_an[c("mutation", tPatients_ID)]#reorder columns 

```