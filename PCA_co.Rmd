---
title: "kmeans -> Dmut"
author: "Elias Benjamin Farr"
date: "17 Mai 2019"
output: html_document
---

#Loading Data
```{r Load.Data}
allDepMapData = readRDS("path/to/your/directory/DepMap19Q1_allData.RDS")
BCCL_Numbers = which(allDepMapData$annotation[4]== "Breast Cancer") 
BCCL_Annotation = subset(allDepMapData$annotation, Primary.Disease == "Breast Cancer")
#see what we got
summary(BCCL_Annotation)
# copy expression matrix to new dataframes
df1 <- allDepMapData$expression
df2 <- allDepMapData$copynumber
df3 <- allDepMapData$kd.ceres
df4 <- allDepMapData$kd.prob
#change column names to numbers for easier handling
names(df1) <- c(1:544)
names(df2) <- c(1:544)
names(df3) <- c(1:544)
names(df4) <- c(1:544)
#extract BCCL as dataframe
BCCL_Expression <- as.data.frame( df1[, c(BCCL_Numbers)])
BCCl_Copynumber <- as.data.frame( df2[, c(BCCL_Numbers)])
BCCL_kd.ceres <- as.data.frame( df3[, c(BCCL_Numbers)])
BCCL_kd.prob <- as.data.frame( df4[, c(BCCL_Numbers)])
dim(BCCL_Expression)
dim(BCCl_Copynumber)
dim(BCCL_kd.ceres)
dim(BCCL_kd.prob)
#reorder rows alphabetically
BCCL_Expression <- BCCL_Expression[order(rownames(BCCL_Expression)), ]
BCCl_Copynumber <- BCCl_Copynumber[order(rownames(BCCl_Copynumber)), ]
BCCL_kd.ceres <- BCCL_kd.ceres[order(rownames(BCCL_kd.ceres)), ]
BCCL_kd.prob <- BCCL_kd.prob[order(rownames(BCCL_kd.prob)), ]
#subset Mutation matrix in BCCL
BCCL_Mutation <- allDepMapData$mutation[c(BCCL_Numbers)]

Patients_ID <- BCCL_Annotation[1] #get patients ID from annotation matrix
tPatients_ID <- t(Patients_ID) #transpose Patients_ID because it was a column and we want to insert it as row
rownameskdc <- rownames(BCCL_kd.ceres) # save old rownames
existingDF <- BCCL_kd.ceres  # define variables for BCCL_kd.ceres
r <- 1
newrow <- tPatients_ID
#defining a function we can use more often to insert rows
insertRow <- function(existingDF, newrow, r) { 
    existingDF[seq(r+1,nrow(existingDF)+1),] <- existingDF[seq(r,nrow(existingDF)),]
    existingDF[r,] <- newrow
    existingDF
}
BCCL_kd.ceres_ID <- insertRow(existingDF, newrow, r)
rownames(BCCL_kd.ceres_ID) <- c("Deep_ID", rownameskdc) # change rownames back 
BCCL_kd.ceres_ID[1:2, ]
#do the same with other 3 dataframes
rownamesex <- rownames(BCCL_Expression) #save rownames
existingDF <- BCCL_Expression  # define variables for BCCL_Erpression
r <- 1
newrow <- tPatients_ID
BCCL_Expression_ID <- insertRow(existingDF, newrow, r)
rownames(BCCL_Expression_ID) <- c("Deep_ID", rownamesex)
rownamescn <- rownames(BCCl_Copynumber) #save rownames
existingDF <- BCCl_Copynumber  # define variables for BCCL_Copynumber
r <- 1
newrow <- tPatients_ID
BCCl_Copynumber_ID <- insertRow(existingDF, newrow, r)
rownames(BCCl_Copynumber_ID) <- c("Deep_ID", rownamescn)
rownameskdp <- rownames(BCCL_kd.prob) #save rownames
existingDF <- BCCL_kd.prob  # define variables for BCCL_kd.prob
r <- 1
newrow <- tPatients_ID
BCCL_kd.prob_ID <- insertRow(existingDF, newrow, r)
rownames(BCCL_kd.prob_ID) <- c("Deep_ID", rownameskdp)
```

#kmeans with CERES scores
```{r kmeans ceres}
#loading required packages
install.packages("tidyverse")
install.packages("factoextra")
library(tidyverse)
library(cluster)
library(factoextra)

#Loading mutImpact matrix
pre_mutImpact <- BCCL_kd.ceres
colnames(pre_mutImpact)<-tPatients_ID
mutImpact <- matrix( , nrow = 17634, ncol = 28)
colnames(mutImpact)<-colnames(pre_mutImpact)
rownames(mutImpact)<-rownames(pre_mutImpact)
for (j in 1:ncol(pre_mutImpact)){
  lineID <- colnames(pre_mutImpact)[j] #select a column-name aka cell line
  for (i in 1:nrow(pre_mutImpact)){
    GOI <- rownames(pre_mutImpact)[i] #select a gene
    if (GOI %in% BCCL_Mutation[[lineID]]$Hugo_Symbol){
      mutImpact[i, j] <- pre_mutImpact[i, j]
    } else {
      mutImpact[i, j] <- NA
    }#replace CERES value with NA in case the gene is not mutated
  }
}

# selecting only genes mutated at least once and with Ceres >= 0

mutImpact_c = mutImpact[rowSums(is.na(mutImpact)) != ncol(mutImpact),]# remove all genes withall NA values
rownamesmutImpc = rownames(mutImpact_c)
mutImpact_c = cbind(rownamesmutImpc, mutImpact_c[,2:ncol(mutImpact_c)]) # insert new column with row names
dim(mutImpact_c) # check gene reduction 
rownameskdc2 = rownames(BCCL_kd.ceres)
BCCL_kd.ceres_2 = cbind(rownameskdc2, BCCL_kd.ceres[,2:ncol(BCCL_kd.ceres)]) # insert new column with row names
BCCL_kd.ceres_3 = BCCL_kd.ceres_2[BCCL_kd.ceres_2[,"rownameskdc2"] %in%  mutImpact_c[,"rownamesmutImpc"],] 
BCCL_kd.ceres_3 = BCCL_kd.ceres_3[,-c(1)]
BCCL_kd.ceres_3 = cbind(BCCL_kd.ceres_3, rowMeans(BCCL_kd.ceres_3)) #calculate rowmeans 
BCCL_kd.ceres_3 = BCCL_kd.ceres_3[rowMeans(BCCL_kd.ceres_3)<= 0,] # deletion of genes with CERES > 0

#determining optimal cluster number k
BCCL_kd.ceresKS = BCCL_kd.ceres_3[,-c(28)] # remove CERES average column

CERES_Optimal_K <- function(BCCL_kd.ceresKS, specifier) {
  output <- lapply(1:ncol(BCCL_kd.ceresKS), function(a){
   df <- scale(BCCL_kd.ceresKS[,a]) # pick one column of input data and scale 
   wss <-(nrow(df-1))*sum(apply(df,2,var)) #compute wss
   for (i in 2:15){ # for k between 2 and 15
     set.seed(1234)
     wss[i] <- sum(kmeans(df, centers = i)$withinss)} 
   return(wss)
  })
names (output) <- colnames(BCCL_kd.ceresKS) # rename the output 
return(output)
}

BCCL_kd.ceres_optKS <- CERES_Optimal_K(BCCL_kd.ceresKS, "CERES Optimal Clusters k") 

# plotting wss function 
optimalKprocessedData <- lapply(seq_along(BCCL_kd.ceres_optKS), function(a){
  dtPicker <- as.data.frame(BCCL_kd.ceres_optKS[[a]]) # one vector picked and formatted into dataframe
  dtPicker$Sample <- names(BCCL_kd.ceres_optKS)[a] #sample added as label
  dtPicker$OptimalK <- 1:nrow(dtPicker) 
  return(dtPicker)
})

optimalKprocessedData <- as.data.frame(rbindlist(optimalKprocessedData)) # output into dataframe
colnames(optimalKprocessedData) <- c("WSS", "Sample", "OptimalK")

# using ggplot to plot output 
ggplot(data = optimalKprocessedData, aes(x=OptimalK, y=WSS))+
  geom_line(aes(color=Sample))+
  labs(title = 'Optimal number of clusters k', x = 'Number of clusters k', y = 'WSS') +
  theme_minimal() +
           theme(legend.position ='bottom',
                  plot.title = element_text(hjust = 0.5),
                  axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
                  legend.title= element_blank(),
                  axis.title.x = element_blank(),
                  strip.text.y = element_text(angle = 0))


# k means clustering with optimal cluster number=3
km_CERES= kmeans(x = BCCL_kd.ceres_3, centers = 3, nstart = 10)
table(km_CERES$cluster)
fviz_cluster(km_CERES, data=BCCL_kd.ceres_3, labelsize = 6) # plotting clusters

km_CERES$cluster["ERBB2"]
km_CERES$cluster["ERBB2IP"]
km_CERES$cluster["MYCBP"]
km_CERES$cluster["PARP10"]
km_CERES$cluster["PIK3CA"] 

# all driver mutations in cluster 2 when centers = 2
# all driver mutations but ERBB2IP in cluster 3 when centers = 4 => hence ERBB2IP eliminate

data_cluster = km_CERES$cluster
rownames(data_cluster) = rownames(BCCL_kd.ceres_3)
data_clus_3 = BCCL_kd.ceres_3[data_cluster == 3,] #dataframe with all 1148 genes in same cluster as driver mutations 

barplot(data_clus_3[,"rowMeans(BCCL_kd.ceres_3)"], main="Gene cluster 3", xlab="CERES scores") 


#LABELING DRIVER MUTATIONS 
# CCND mutation not present in BCCL_kd.ceres_3 matrix but ERBB2, ERBB2IP, MYCBP, PARP10 and PIK3CA found. ERBB2IP however not in same cluster as other driver mutations 

drivermut =  c("ERBB2","MYCBP", "PARP10", "PIK3CA") # create vector with driver mutation names
data_clus_3e = data_clus_3
data_clus_3e["Driver mutation"] <- sapply(1:nrow(data_clus_3), function(j){
     if(rownames(data_clus_3e)[j] %in% drivermut){
         data_clus_3e[j,1] = "driver mutation"
     } else {
         data_clus_3e[j,1] = "no driver mutation"
     }
  }) # labeling driver mutations with "driver mutation" in data_clus_3e 
```

# Data visualisation of 4 driver mutations 
```{data visualisation}
install.packages("reshape")
install.packages("wesanderson")
library("reshape")
library("wesanderson")

#barplot for fun 
barplot(data_clus_3[,"rowMeans(BCCL_kd.ceres_3)"], main="Gene cluster 3", xlab="CERES scores") 

# CERES_boxplot
GOI= BCCL_kd.ceres[c("ERBB2","MYCBP", "PARP10", "PIK3CA"),]
CERES_driver_mut= melt(GOI)
CERES_driver_mut$variable=rep(c("ERBB2","MYCBP", "PARP10", "PIK3CA"), ncol(GOI))

CERES_boxplot = ggplot(CERES_driver_mut, aes(x = variable, y = value)) +
       geom_boxplot(aes(fill=variable), outlier.alpha = 0.7,
                     outlier.colour = "red", outlier.shape = 20, outlier.size = 2) +
        labs(title = 'CERES scores of selected driver mutations', x = 'Selected driver   mutations', y = 'CERES scores') +
            theme_minimal() +
            geom_jitter(width = 0.2) +
  CERES_boxplot = ggplot(CERES_driver_mut, aes(x = variable, y = value)) +
       geom_boxplot(aes(fill=variable), outlier.alpha = 0.7,
                     outlier.colour = "grey", outlier.shape = 20, outlier.size = 2) +
        labs(title = 'CERES scores of selected driver mutations', x = 'Selected driver   mutations', y = 'CERES scores') +
            theme_minimal() +
            geom_jitter(width = 0.2) +
            scale_fill_manual(values=wes_palette(n=4, name="Royal2")) +
            theme(legend.position ='none',
                  plot.title = element_text(hjust = 0.4),
                  axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
                  legend.title= element_blank(),
                  axis.title.x = element_blank(),
                  strip.text.y = element_text(angle = 0))
CERES_boxplot

  
#Expression_boxplot
GOI_Exp= BCCL_Expression[c("ERBB2","MYCBP", "PARP10", "PIK3CA"),]
Expression_driver_mut= melt(GOI_Exp)
Expression_driver_mut$variable=rep(c("ERBB2","MYCBP", "PARP10", "PIK3CA"), ncol(GOI_Exp))

Expression_boxplot = ggplot(Expression_driver_mut, aes(x = variable, y = value)) +
       geom_boxplot(aes(fill=variable), outlier.alpha = 0.7,
                     outlier.colour = "grey", outlier.shape = 20, outlier.size = 2) +
        labs(title = 'Transcripts per million (TPM) of selected driver mutations', x = 'Selected driver mutations', y = 'Transcripts per million (TPM)') +
            theme_minimal() +
            geom_jitter(width = 0.2) +
            scale_fill_manual(values=wes_palette(n=4, name="Royal2")) +
            theme(legend.position ='none',
                  plot.title = element_text(hjust = 0.4),
                  axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
                  legend.title= element_blank(),
                  axis.title.x = element_blank(),
                  strip.text.y = element_text(angle = 0))
Expression_boxplot
```
```

#PCA using BCCL_kd.ceres_3
```{r PCA BCCL_kd.ceres_3}
install.packages("ggfortify")
library(ggfortify)

tBCCL_kd.ceres = t(BCCL_kd.ceres_3[,-c(28)]) # transformation of BCCL_kd.ceres_3 matrix
CERES.pca = prcomp(tBCCL_kd.ceres, center = T, scale = T, rank = 2)  
summary(CERES.pca)

plot(CERES.pca, type = "l")  # Identify PCs with most variabilit SS
autoplot(CERES.pca, label = TRUE, label.size = 3) # need to add colour based on whether driver mutation or not

CERES.pca.loadings = CERES.pca$rotation # loadings PC1 and PC2
Sor.CERES.pca.load= -CERES.pca.loadings [order(CERES.pca.loadings[,1]),] #managed to order PC1 column according to size (PC2 not yet)
Sor.CERES.pca.load[1:200,] # first 200 genes do not contain driver mutations 
```








#Alternativ Code 

#kmeans for Expression data test
```{r kmeans}
BCCL_Expression_rmv = BCCL_Expression[rowSums(BCCL_Expression != 0) > 0, ]
BCCL_Expression_rmv_s = scale(BCCL_Expression)
km= kmeans(x = BCCL_Expression_rmv_s, centers = 2, nstart = 10)
table(km$cluster)
wss = sapply(2:10, function(k) {
    kmeans(x = BCCL_Expression_rmv_s, centers = k)$tot.withinss
})
plot(2:10, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares") # optimal number 4 clusters

km = kmeans(x = BCCL_Expression_rmv_s, centers = 4, nstart = 10)
table(km$cluster)

fviz_cluster(km, data=BCCL_Expression_rmv_s)

#trying to determine optimal cluster number with silhouette method- not yet functional 

s <- sapply(2:10, function(k) {
  kmeans(x=BCCL_Expression_rmv_s, centers = k);
  D = dist(BCCL_Expression_rmv_s);
  si = silhouette(km$cluster, D);
  si_sum = (summary(si, FUN = mean))
})
```


```{r code}
BCCL_kd.ceres_3 = BCCL_kd.ceres_2[BCCL_kd.ceres_2[,"rownameskdc2"] %in% mutImpact_c[,"rownamesmutImpc"],] # reduce BCCL_kd.ceres_2 matrix to genes mutated at least once
```
#Alternative second try to label mutations
```{r}
BCCL_kd.ceres_an <- BCCL_kd.ceres #generate new data frame
colnames(BCCL_kd.ceres_an) <- rownames(BCCL_kd.ceres)

#generate new column containing information on mutation status
BCCL_kd.ceres_an$mutation <- sapply(1:nrow(BCCL_kd.ceres), function(j){
     if(rownames(BCCL_kd.ceres_an)[j] %in% rownames(mutImpact_c)){
         BCCL_kd.ceres_an[j,1] = "mutation"
     } else {
         BCCL_kd.ceres_an[j,1] = "no mutation"
     }
  })
BCCL_kd.ceres_an <- BCCL_kd.ceres_an[c("mutation", tPatients_ID)]#reorder columns 
```


#Expression PCA
``` {r PCA}
install.packages("ggfortify")
library(ggfortify)

tBCCL_Expression = t(BCCL_Expression)
Expression.pca = prcomp(tBCCL_Expression, center = T, scale = F, rank = 2)  # scaling not possible due to zeros # rank = 2 since only interested in first 2 PCA components 
summary(Expression.pca)

plot(Expression.pca, type = "l")  # First 2 components = most of data  variability using Elbow-method 
autoplot(Expression.pca, label = TRUE, label.size = 3) # need to add colour based on whether driver mutation or not

Expression.pca.loadings = Expression.pca$rotation # laodings PC1 and PC2
Sor.Expr.pca.load= -Expression.pca.loadings [order(Expression.pca.loadings[,1], Expression.pca.loadings[,2]),] #managed to order PC1 column according to size (PC2 not yet)
Sor.Expr.pca.load[1:200,] # first 200 genes do not contain driver mutations - perhaps assign rank

```

#Same process for CERES scores
```{r PCA Ceres}
tBCCL_kd.ceres = t(BCCL_kd.ceres)
Ceres.pca = prcomp(tBCCL_kd.ceres, center = T, scale = T, rank = 2)  
summary(Ceres.pca)

plot(Ceres.pca, type = "l")  # First 2 components = most of data  variability using Elbow-method 
autoplot(Ceres.pca, label = TRUE, label.size = 3) # need to add colour based on whether driver mutation or not

Ceres.pca.loadings = Ceres.pca$rotation # loadings PC1 and PC2
Sor.Ceres.pca.load= -Ceres.pca.loadings [order(Ceres.pca.loadings[,1]),] #managed to order PC1 column according to size (PC2 not yet)
Sor.Ceres.pca.load[1:200,] # first 200 genes do not contain driver mutations - perhaps assign rank
```
