---
title: "PCA and related plots -> Dmut"
author: "Elias Benjamin Farr"
date: "17 Mai 2019"
output: html_document
---
Objective of PCA:
  + For this dimension reduction process, we try to find similarity in the dataset.
  + Prinicipal Components describe the directions with the most varianc in data.
  
#Loading Data
```{r Load.Data}
allDepMapData = readRDS("path/to/your/directory/DepMap19Q1_allData.RDS")
BCCL_Numbers = which(allDepMapData$annotation[4]== "Breast Cancer") 
BCCL_Annotation = subset(allDepMapData$annotation, Primary.Disease == "Breast Cancer")
#see what we got
summary(BCCL_Annotation)
# copy expression matrix to new dataframes
df1 <- allDepMapData$expression
df2 <- allDepMapData$copynumber
df3 <- allDepMapData$kd.ceres
df4 <- allDepMapData$kd.prob
#change column names to numbers for easier handling
names(df1) <- c(1:544)
names(df2) <- c(1:544)
names(df3) <- c(1:544)
names(df4) <- c(1:544)
#extract BCCL as dataframe
BCCL_Expression <- as.data.frame( df1[, c(BCCL_Numbers)])
BCCl_Copynumber <- as.data.frame( df2[, c(BCCL_Numbers)])
BCCL_kd.ceres <- as.data.frame( df3[, c(BCCL_Numbers)])
BCCL_kd.prob <- as.data.frame( df4[, c(BCCL_Numbers)])
dim(BCCL_Expression)
dim(BCCl_Copynumber)
dim(BCCL_kd.ceres)
dim(BCCL_kd.prob)
#reorder rows alphabetically
BCCL_Expression <- BCCL_Expression[order(rownames(BCCL_Expression)), ]
BCCl_Copynumber <- BCCl_Copynumber[order(rownames(BCCl_Copynumber)), ]
BCCL_kd.ceres <- BCCL_kd.ceres[order(rownames(BCCL_kd.ceres)), ]
BCCL_kd.prob <- BCCL_kd.prob[order(rownames(BCCL_kd.prob)), ]
#subset Mutation matrix in BCCL
BCCL_Mutation <- allDepMapData$mutation[c(BCCL_Numbers)]
```

#include patients ID as first row in BCCL dataframes
```{r echo=FALSE}
Patients_ID <- BCCL_Annotation[1] #get patients ID from annotation matrix
tPatients_ID <- t(Patients_ID) #transpose Patients_ID because it was a column and we want to insert it as row
rownameskdc <- rownames(BCCL_kd.ceres) # save old rownames
existingDF <- BCCL_kd.ceres  # define variables for BCCL_kd.ceres
r <- 1
newrow <- tPatients_ID
#defining a function we can use more often to insert rows
insertRow <- function(existingDF, newrow, r) { 
    existingDF[seq(r+1,nrow(existingDF)+1),] <- existingDF[seq(r,nrow(existingDF)),]
    existingDF[r,] <- newrow
    existingDF
}
BCCL_kd.ceres_ID <- insertRow(existingDF, newrow, r)
rownames(BCCL_kd.ceres_ID) <- c("Deep_ID", rownameskdc) # change rownames back 
BCCL_kd.ceres_ID[1:2, ]
#do the same with other 3 dataframes
rownamesex <- rownames(BCCL_Expression) #save rownames
existingDF <- BCCL_Expression  # define variables for BCCL_Erpression
r <- 1
newrow <- tPatients_ID
BCCL_Expression_ID <- insertRow(existingDF, newrow, r)
rownames(BCCL_Expression_ID) <- c("Deep_ID", rownamesex)
rownamescn <- rownames(BCCl_Copynumber) #save rownames
existingDF <- BCCl_Copynumber  # define variables for BCCL_Copynumber
r <- 1
newrow <- tPatients_ID
BCCl_Copynumber_ID <- insertRow(existingDF, newrow, r)
rownames(BCCl_Copynumber_ID) <- c("Deep_ID", rownamescn)
rownameskdp <- rownames(BCCL_kd.prob) #save rownames
existingDF <- BCCL_kd.prob  # define variables for BCCL_kd.prob
r <- 1
newrow <- tPatients_ID
BCCL_kd.prob_ID <- insertRow(existingDF, newrow, r)
rownames(BCCL_kd.prob_ID) <- c("Deep_ID", rownameskdp)
```


#kmeans for Expression data test
```{r kmeans}
install.packages("tidyverse")
install.packages("factoextra")
library(tidyverse)
library(cluster)
library(factoextra)

BCCL_Expression_rmv = BCCL_Expression[rowSums(BCCL_Expression != 0) > 0, ]
BCCL_Expression_rmv_s = scale(BCCL_Expression)
km= kmeans(x = BCCL_Expression_rmv_s, centers = 2, nstart = 10)
table(km$cluster)
wss = sapply(2:10, function(k) {
    kmeans(x = BCCL_Expression_rmv_s, centers = k)$tot.withinss
})
plot(2:10, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares") # optimal number 4 clusters

km = kmeans(x = BCCL_Expression_rmv_s, centers = 4, nstart = 10)
table(km$cluster)

fviz_cluster(km, data=BCCL_Expression_rmv_s)


#Same with ceres Matrix

BCCL_CERES_s = scale(BCCL_kd.ceres)
km_CERES= kmeans(x = BCCL_CERES_s, centers = 2, nstart = 10)
table(km_CERES$cluster)
wss = sapply(2:10, function(k) {
    kmeans(x = BCCL_CERES_s, centers = k)$tot.withinss
})
plot(2:10, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares") # optimal number 4 

km_CERES = kmeans(x = BCCL_CERES_s, centers = 4, nstart = 10)
table(km_CERES$cluster)

fviz_cluster(km_CERES, data=BCCL_CERES_s)



#trying to determine optimal cluster number with silhouette method

s <- sapply(2:10, function(k) {
  kmeans(x=BCCL_Expression_rmv_s, centers = k);
  D = dist(BCCL_Expression_rmv_s);
  si = silhouette(km$cluster, D);
  si_sum = (summary(si, FUN = mean))
})

```


Rest not yet complete for now!


K means clustering mit mutImpact Matrix- not yet successfull due to NA values 

#Loading mutImpact Matrix

```{r loading mutImpactMatrix}

#Loading mutImpact matrix
pre_mutImpact <- BCCL_kd.ceres
colnames(pre_mutImpact)<-tPatients_ID
mutImpact <- matrix( , nrow = 17634, ncol = 28)
colnames(mutImpact)<-colnames(pre_mutImpact)
rownames(mutImpact)<-rownames(pre_mutImpact)
for (j in 1:ncol(pre_mutImpact)){
  lineID <- colnames(pre_mutImpact)[j] #select a column-name aka cell line
  for (i in 1:nrow(pre_mutImpact)){
    GOI <- rownames(pre_mutImpact)[i] #select a gene
    if (GOI %in% BCCL_Mutation[[lineID]]$Hugo_Symbol){
      mutImpact[i, j] <- pre_mutImpact[i, j]
    } else {
      mutImpact[i, j] <- NA
    }#replace CERES value with NA in case the gene is not mutated
  }
}

#selecting only genes mutated once
mutImpact_c = mutImpact[rowSums(is.na(mutImpact)) != ncol(mutImpact),]# remove all genes withall NA values
rownamesmutImpc = rownames(mutImpact_c)
mutImpact_c = cbind(rownamesmutImpc, mutImpact_c[,2:ncol(mutImpact_c)]) # insert new column with row names
dim(mutImpact_c) # check gene reduction 
rownameskdc2 = rownames(BCCL_kd.ceres_2)
BCCL_kd.ceres_2 = cbind(rownameskdc2, BCCL_kd.ceres[,2:ncol(BCCL_kd.ceres)]) # insert new column with row names
BCCL_kd.ceres_3 = BCCL_kd.ceres_2[BCCL_kd.ceres_2[,"rownameskdc2"] %in%  mutImpact_c[,"rownamesmutImpc"],] 
BCCL_kd.ceres_3= BCCL_kd.ceres_3[,-c(1)]

# k means clustering with new gene 
BCCL_CERES_an_s = scale(BCCL_kd.ceres_3)
km_CERES_an= kmeans(x = BCCL_CERES_an_s, centers = 2, nstart = 10)
table(km_CERES_an$cluster)
wss = sapply(2:10, function(k) {
    kmeans(x = BCCL_CERES_an_s, centers = k)$tot.withinss
})
plot(2:10, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares") # optimal number 4 

km_CERES_an = kmeans(x = BCCL_CERES_an_s, centers = 4, nstart = 10)
table(km_CERES_an$cluster)

fviz_cluster(km_CERES_an, data=BCCL_CERES_an_s, labelsize = 0)



<<<<<<< HEAD
BCCL_kd.ceres_3 = BCCL_kd.ceres_2[BCCL_kd.ceres_2[,"rownameskdc2"] %in% mutImpact_c[,"rownamesmutImpc"],] # reduce BCCL_kd.ceres_2 matrix to genes mutated at least once

=======
#Alternative second try
BCCL_kd.ceres_an <- BCCL_kd.ceres #generate new data frame
colnames(BCCL_kd.ceres_an) <- rownames(BCCL_kd.ceres)

#generate new column containing information on mutation status
BCCL_kd.ceres_an$mutation <- sapply(1:nrow(BCCL_kd.ceres), function(j){
     if(rownames(BCCL_kd.ceres_an)[j] %in% rownames(mutImpact_c)){
         BCCL_kd.ceres_an[j,1] = "mutation"
     } else {
         BCCL_kd.ceres_an[j,1] = "no mutation"
     }
  })
BCCL_kd.ceres_an <- BCCL_kd.ceres_an[c("mutation", tPatients_ID)]#reorder columns 
>>>>>>> 
```






AUSSORTIERTER CODE

```{r loop}
#now I need a loop where for each gene, not a rowname in MutImpact_c replace "mutation" with "No mutation"
#not yet quite functional yet 
for(j in 1:nrow(BCCL_kd.ceres_2)){
  if(rownames(BCCL_kd.ceres_2)[j] %in% rownames(mutImpact_c)){
   BCCL_kd.ceres_3 = BCCL_kd.ceres_2[-c(j),]
  } else {}
}

```

#test with autoplot ggfortify but not yet successfull- error message frequent ==> Error in inds_combine(.vars, ind_list) : Position must be between 0 and n
```{r ggfortify test}
install.packages("ggfortify")
library(ggfortify)
autoplot(kmeans(mutImpact, 2), data = mutImpact,label = TRUE, label.size = 3, frame = TRUE)

```


#PCA but not yet complete!
``` {r PCA}
install.packages("ggfortify")
library(ggfortify)

tBCCL_Expression = t(BCCL_Expression)
Expression.pca = prcomp(tBCCL_Expression, center = T, scale = F, rank = 2)  # scaling not possible due to zeros # rank = 2 since only interested in first 2 PCA components 
summary(Expression.pca)

plot(Expression.pca, type = "l")  # First 2 components = most of data  variability using Elbow-method 
autoplot(Expression.pca, label = TRUE, label.size = 3) # need to add colour based on whether driver mutation or not

Expression.pca.loadings = Expression.pca$rotation # laodings PC1 and PC2
Sor.Expr.pca.load= -Expression.pca.loadings [order(Expression.pca.loadings[,1], Expression.pca.loadings[,2]),] #managed to order PC1 column according to size (PC2 not yet)
Sor.Expr.pca.load[1:200,] # first 200 genes do not contain driver mutations - perhaps assign rank

```


Things to do: 
* manually scale Expression values 
* add column to tBCCL_expression which shows mutation or not from  MutImpact Matrix (?) 
* could also order matrix also according to PC2
* assign rank to genes according to PC1 und PC2 (insert 2 columns with appropriate rank- can identify driver mutations)

#Same process for CERES scores (needs to be adapted if any changes made above)

```{r PCA Ceres}
tBCCL_kd.ceres = t(BCCL_kd.ceres)
Ceres.pca = prcomp(tBCCL_kd.ceres, center = T, scale = T, rank = 2)  
summary(Ceres.pca)

plot(Ceres.pca, type = "l")  # First 2 components = most of data  variability using Elbow-method 
autoplot(Ceres.pca, label = TRUE, label.size = 3) # need to add colour based on whether driver mutation or not

Ceres.pca.loadings = Ceres.pca$rotation # loadings PC1 and PC2
Sor.Ceres.pca.load= -Ceres.pca.loadings [order(Ceres.pca.loadings[,1]),] #managed to order PC1 column according to size (PC2 not yet)
Sor.Ceres.pca.load[1:200,] # first 200 genes do not contain driver mutations - perhaps assign rank
```

#cleaning matrix of AARSP1 column
rmv_AARSP1 = which(colnames(tBCCL_Expression) %in% c("AARSP1")) 
cl_tBCCL_Expression = cl_tBCCL_Expression[, -rmv_AARSP1] # however scaling still does not work since Zero-column still there need now to filter all columns which are 0

