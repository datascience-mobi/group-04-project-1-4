---
title: "MutImpactmatrix, k-means, Wilcoxon"
author: "Elias Benjamin Farr"
date: "17 Mai 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Hello lisa :) 
Thank you for this warm welcome, Elias! :)

#requirements to run this code#
in order to run this you will need: BCCL_kd.ceres, tPatients_ID, BCCL_Mutation



#Generate pre_mutImpact matrix containing all CERES values and with IDs as colnames#
```{r} 
pre_mutImpact <- BCCL_kd.ceres
colnames(pre_mutImpact)<-tPatients_ID
```


#generate empty mutImpact matrix
```{r}
mutImpact <- matrix( , nrow = 17634, ncol = 28)
colnames(mutImpact)<-colnames(pre_mutImpact)
rownames(mutImpact)<-rownames(pre_mutImpact)
```

#fill mutImpact matrix with values
```{r}
for (j in 1:ncol(pre_mutImpact)){
  lineID <- colnames(pre_mutImpact)[j] #select a column-name aka cell line
  for (i in 1:nrow(pre_mutImpact)){
    GOI <- rownames(pre_mutImpact)[i] #select a gene
    if (GOI %in% BCCL_Mutation[[lineID]]$Hugo_Symbol){
      mutImpact[i, j] <- pre_mutImpact[i, j]
    } else {
      mutImpact[i, j] <- NA
    }#replace CERES value with NA in case the gene is not mutated
  }
}
```

##Paired Wilcoxon signed rank test

```{r}
#generate matrix of driver mutations
drivMat <- mutImpact[ , c(#colnr of DV)]

#generate 2nd vector of potential SSTS, i = gene
potSST <- as.vector(mutImpact[a, ])

#select driver mutation to find correspaonding SSTs
for i in (1:ncol(drivMat) function() {
  Dvm <- as.vector(drivMat[ ,i]
})

#suggested loop to design Wilcoxon matrix
wlxmat <- lapply(1:nrow(mutImpact), function(a) {
  potSST <- as.vector(mutImpact[a, ])
  wilcox.test(Dvm, potSST, paired = TRUE, na.action = na.exclude)
})
#returns error:  Error in wilcox.test.default(Dvm, potSST, paired = TRUE, na.action = na.exclude) : 
  #not enough (finite) 'x' observations 

#new try... "by foot"
wlxmat <- sapply(1:nrow(mutImpact), function(a) {
  wil.p = 0
  wil.p.sum = 0
  non.na = 0
  for (i in 1:ncol(mutImpact)) {
    if (!is.na(mutImpact["BPI",i]) & !is.na(mutImpact[a,i]) & mutImpact["BPI",i]!=mutImpact[a,i]) {#here BPI is supposed to be a DV
        wil.p = wilcox.test(mutImpact["BPI",i],mutImpact[a,i], paired = TRUE)$p.value
        non.na = non.na + 1
    } else {
        wil.p = 0
    }
    wil.p.sum = wil.p.sum + wil.p
}
wil.p.mean = wil.p.sum/non.na
})

#problem is that you cannot change rownames and there is something wrong with the computation as some values are 1 (NAN are the values in case there is no co-existence of the DV and the SST)
```
##So maybe it would be useful to try a PCA on the mutImpact matrix, since it did not really work out in the expression matrix.

```{r}
table(is.na(mutImpact)) #counting the NAs over the whole mutImpact matrix.
PCA_mutimpact <- mutImpact #creating a copy
dim(PCA_mutimpact) #removing all NAs by a for loop and replacing them with a zero
for (i in 1:17634){} #for all genes (rows)
  for(j in 1:28) #for all cell lines (columns)
    if (is.na(PCA_mutimpact[i,j])){
      PCA_mutimpact[i,j] <- 0
    }
}
}
anyNA(PCA_mutimpact) #verify if all NAs are removed
scale(PCA_mutimpact, center = TRUE, scale = TRUE) #unit variance as PCA preperation
mutImpact.pca = prcomp(PCA_mutimpact, center = F, scale. = F) #set the parameters false since we already centered and scaled the data
print(mutImpact.pca)
plot(mutImpact.pca, type = "l") #scree plot to detect the PCs explaining most of the variance: PC 1 and 2 have each 3-4% explained variances, PC3-8 approx. 1% each. We ttry to continue with PC 1/2.
install.packages("ggfortify")
library(ggfortify)
df <- pca[c(1,2)]
df <- as.data.frame(sapply(pca[c(1,2)], scale))#to eliminate the error "Error in colMeans(x, na.rm = TRUE) : 'x' must be numeric", since cateogorical variables cannot be sclaed
autoplot(prcomp(df), loadings = TRUE, loacings.colour = "turquoise", loadings.label = TRUE, loadings.label.size = 3) #we receive the PCA plot