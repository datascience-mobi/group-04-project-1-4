---
title: 'Final Report: Identification of SSTs'
author: "Elias Benjamin Farr, Lennart Linke, Lisa Marie Milchsack, Salome Steinke"
date: "17. Juli 2019"
output:
  html_document:
    highlight: pygments
    number_sections: yes
    theme: lumen
    toc: yes
    df_print: paged
  word_document:
    toc: yes
---

<style type="text/css">

body{ /* Normal  */
      font-size: 20px;
  }
td {  /* Table  */
  font-size: 16px;
}
h1.title {
  font-size: 40px;
  color: Red;
  font-family: "Segoe UI"";
}
h1 { /* Header 1 */
  font-size: 28px;
  color: #fba92e;
}
h2 { /* Header 2 */
    font-size: 22px;
  color: #158597;
}
h3 { /* Header 3 */
  font-size: 18px;
  font-family: "Times New Roman", Times, serif;
  color: #158597;
}
code.r{ /* Code block */
    font-size: 16px;
}
pre { /* Code block - determines code spacing between lines */
    font-size: 14px;
}

<blockquote class="blockquote-reverse">
  <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer posuere erat a ante.</p>
  <small>Someone famous in <cite title="Source Title">Source Title</cite></small>
</blockquote>

<table class="table table-striped table-hover ">
  <thead>
    <tr>
      <th>#</th>
      <th>Column heading</th>
      <th>Column heading</th>
      <th>Column heading</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Column content</td>
      <td>Column content</td>
      <td>Column content</td>
    </tr>
    </tbody>
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error = FALSE)
```
# Introduction

## Revision: Breast Cancer, a challenging disease
> "The heterogeneity of breast cancers makes them fascinating and challenging to diagnose and treat." *Please, add whom you quoted from*
>  "The heterogeneity of breast cancers makes them both a fascinating and challenging solid tumor to diagnose and treat." quote.footer("--- *A novel therapeutic target for triple negative breast cancer*, Raj Kumar 2016") #thats what i've found -elias

If you grow up in a western country in the beginning 21th century, there are two sorts of tumors, you will definately notice before you leave high school. The first one is lung cancer, gaining its questionable fame with pictures leaping out of every box of cigarettes. The second one went famous with broadly reported stories about Angelina Jolie or famous old german universities. However, breast cancer isn't just the story of attractive women or research institutes making themselves ridicolous, it is also a story of suffering and death.
We think about breast cancer as the most prevalent tumor disease worldwide. It is also one of the most deathly malignant tumors, with far more than 600.000 deaths reported in 2017 (GBD 2017). Due to an increase of a sixth in percentage of world population suffering from this ilness, in the past 27 years, it is advisable to do something in the future. 
But there is hope. In the past decades, breast cancer therapy evolved, diminishing the age standardized death rate from 15.10 to 10.00 in western europe, which is a decrease of about a third (GBD 2017). 
Up to a point this is satisfying, on the other hand there are still a lot of challenges remaining, for example to find an effective prevention approach (Sledge et al. 2014). One group of methods increasing its powers every days are computerbased methods. Their share of ... and ... is astonishingly large . This makes us all excited about what comes in the future. Until Meanwhile, we will focus on our project, teaching ourselves in a nice manner, how useful a fast thinking computer is in research. 

According to the latest reports of breast cancer prevalence, the current state is very serious:
+ Breast cancer ranks second in worldwide cancer case numbers (Hutchinson 2010)
+ In Germany there are 70,000 new cases annually. (Barnes, Kraywinkel et al. 2016)
+ This makes ~ 30% of all reported cases of tumor diseases.(Robert-Koch-Institut 2017)

## Driver Mutations: the driving force in tumorigenesis

Driver mutations (DV) are what is to be seen as the ticket of admission to the different stages of cancer growth. Thus, the acquisition of driver mutations is essential for tumour initiation, transformation as well as progression and metastasis. According to Bert Vogelstein three mutations in genes displaying a crucial function in cell proliferation, DNA integrity and cellular motility are enough to drive a normal cell into aberrant growth and malignancy:

> "Focusing on driver-gene mutations and the pathways they control has rendered complex cancer-genome landscapes intelligible. In solid tumors of adults, alterations in as few as three driver genes appear to suffice for a cell to evolve into an advanced cancer." quote.footer("--- *The Path to Cancer - Three Strikes and You're Out*, Bert Vogelstein 2015")

These DVs comprise both gain-of-function mutations in (proto-)oncogenes which usually promote cell proliferation and loss-of-function mutations in tumour suppressor genes which usually decelerate the cell cycle as well as genes involved in DNA repair and proofreading. Thereby, the cell acquires indispensable properties in tumorigenesis such as immortality, continous proliferation, immune and apoptosis resistance and the ability to promote angiogenesis. Examples for prominent oncogenes are k-ras and b-raf encoding kinases regulating a complex network of proteins involved in cellular growth when bound to ATP or GTP, respectively. On the other hand the most illustrious tumour suppressor gene is p53 whose physiological role is to induce cell senescence and apoptosis in case of DNA damage, a condition often encountered in cancer cells.

Due to their essential role in tumour progression DVs are predisposed targets in novel approaches in cancer therapy. For instance, trastuzumab, an antibody against HER2 which is an oncogene promoting cell growth while inhibiting apotosis launched in 1998 was proven to reduce the recurrence rate by 50% and mortality by 30%. However, targeting genes or gene products involved in vital cellular processes remains a major challenge as healthy cells expressing the same genes are often affected as well. As therapies tailored to the molecular phenotype of the tumour achieved greater successes than conventional strategies such as chemotherapy and irradiation scientists now focus on identifying other molecular targets with a negligible effect on healthy tissues.  

In our project, we first focus on driver mutations, which can be imagined as the main "force" in tumorigenesis. Certain genes induce/improve tumor growth as a consequence of mutation, such as:
+ Providing tumor cells with a growth advantage
+ Leading to positive selection in microenvironment
Furthermore, driver mutations are also often required for tumor maintenance. (Stratton, Campbell et al. 2009)

## Second-site targets: secret co-operators in tumorigenesis

Driver mutations are not the only genetic factors involved in cancer development. Moreover, tumorigenesis derives from a complex genetic programme comprising several minor and major alterations in gene expression patterns as well as protein regulation. As these factors act synergistically in promoting tumour growth disturbing their interaction might provide another method of inhibiting cancer proliferation. 

The considered factors supporting the effect of driver mutations are often referred to as second-site targets (SSTs) as they do not necessarily confer a growth advantage to the tumour when mutated alone but by genetic interaction with other mutations. Thus, SSTs constitute promising targets in cancer therapy as they are meant to have a less significant effect on the viability of healthy cells because they do not display central regulatory functions. However, identification of these secret co-operators demands the analysis of several parameters reflecting their relevance and function in proliferation such as RNAseq data, data from gene knockouts and mutational analyses.  

Targeting and eliminating driver mutations as a part of tumor treatment is a difficult procedure, since those genes are also essential for survival of non-mutated cells. A differentiation between normal and tumor cell is not possible, thus targeting leads to adverse effects. Plus, high dosages need to be applied. #CITATION
A promising approach is targeting so-called Second Site Targets (SSTs), which are gene mutations interacting genetically with driver mutations to increase cell viability. # CITATION
If knocking out those genes leads to cell lethality, it may lead to new treatment options.

```{r SSTs, eval=FALSE, echo=FALSE, fig.cap="Concept of SSTs", out.width = '100%', fig.align = "center"}
knitr::include_graphics("Concept_of_SSTs.png")
```

Our central question for our project is thereby:
> Which __second-site targets__ interact genetically with __driver mutations__ to promote cell viability and proliferation in breast cell cancers?

# Project outline

## Project design: Our selection of possible driver mutation

+ From literature, we selected possible driver mutations based on three main characteristics:
  1. overexpressed in breast cancer
  2. observed in a relevant percentage of clinical cases
  3. part of processes/pathways of tumorgenesis
  
+ Finally, we selected:

Gene Name | Overexpression rate | Role in Tumorgenesis                   | Sources                                                     |
----------|---------------------|----------------------------------------|-------------------------------------------------------------|
CCND      | ~ 50%               |Cell cycle regulator                    |(Arnold and Papanikolaou 2005)                               |
ERBB2     | ~ 30%               |Encodes endothelial growth factor       |(Slamon, Godolphin et al. 1989)                              |
MYC       | ~ 30 - 50%          |Cell cycle and apoptosis regulator      |(Gabay, Li et al. , Xu, Chen et al. 2010)                    |
PARP10      | ~ 45%               |Regulates differentiation/proliferation |(Siraj, Pratheeshkumar et al. 2018)                          |
PIK3CA    | ~ 30 - 48%          |Interaction with AKT and mTOR pathway   |(Aleskandarany, Rakha et al. 2010, Shimoi, Hamada et al.2018)|

```{r driver mutations, eval=FALSE, echo=FALSE, fig.cap="Possible_Driver_Mutations", out.width = '100%', fig.align = "center"}
knitr::include_graphics("Possible_Driver_Mutations.png")
```

# Methods

## Data cleanup and exploration

Before we start our statistical part, we have to load the required packages as well as the data:

```{r eval=FALSE}
# installation of required packages
install.packages("reshape")
install.packages("wesanderson")
install.packages("tidyverse")
install.packages("factoextra")
install.packages("RColorBrewer")
install.packages("gplots")
install.packages("data.table")
install.packages("ggpubr")


# importing libraries
library(ggplot2)
library(reshape2)
library(data.table)
library(cluster)
library(caTools) 
library(tidyverse)
library(factoextra)
library(wesanderson)
library(RColorBrewer)
library("gplots")
library("ggpubr")

#Setting a sys-path
root.dir = dirname(rstudioapi::getSourceEditorContext()$path)

#Importing the data
data = readRDS(paste0(root.dir, "/DepMap19Q1_allData.RDS")) #read in the data 
```

```{r include=FALSE}
# importing libraries
library(ggplot2)
library(reshape2)
library(data.table)
library(cluster)
library(caTools) 
library(tidyverse)
library(factoextra)
library(wesanderson)
library(RColorBrewer)
library("gplots")
```

```{r Lisa include = FALSE, eval=FALSE}
data = readRDS("C:/Users/lisa-/Desktop/Studium/4. FS/Bioinfo/DepMap19Q1_allData.RDS")
root.dir = "C:/Users/lisa-/Desktop/Studium/4. FS/Bioinfo/project-01-group-04"
```

```{r Salome include=FALSE, eval=FALSE}
data = readRDS("C:/Users/Salome/Documents/4.FS/Bioinfo/DepMap19Q1_allData.RDS")
root.dir = "C:/Users/Salome/Documents/4.FS/Bioinfo/Github/project-01-group-04"
```

```{r Lennart include = FALSE, eval=FALSE}
data = readRDS("L:/UNI/4.FS/BioStat/DepMap19Q1_allData.RDS")
root.dir = "C:/Users/ole-l/Documents/GitHub/project-01-group-04"
```
To get a feeling for the dataset we will have a look at the given data structure.  

```{r include=FALSE}
length(data) #get some info about the data (the dimensions here)
lapply(data, dim) #get an impression on the data
#View(data$mutation) #closer look because data$mutation returns NULL in the command above
lapply(data, function(a) head(a)) #look at the data 
```

We find a dataset containing 6 smaller datasets. Five of them are large data frames while the sixth is a list of data frames. For the extraction of this sixth variable we first separated it fom the others and gave it a new strucure, which is easier to handle.

```{r}
#Extract the mutation data
mut <- data$mutation #pick the mutation data (this has a specific format and neets to be treated separately)
'%!in%' <- function(x,y)!('%in%'(x,y)) #define an operator that will only pick the data that is NOT defined in the list; 
dt_new <- lapply(which(names(data) %!in% "mutation"), function(a) data[[a]]) #extract only non-mutation data
names(dt_new) <- names(data)[which(names(data) %!in% "mutation")] #rename the data with the original names
length(dt_new) #look if it worked (now dim is 5 and NOT 6 (because mutation was removed))
sample_case = c("Breast Cancer") #gives us the opportunity to analyse other groups of cells
samples = data$annotation$DepMap_ID[which(data$annotation$Primary.Disease == sample_case)]
ids = which(names(mut) %in% samples)
dat = lapply(ids, function(a) mut[[a]])
```

We observe a large variety of tumor diseases being recorded by this dataset. Because we want to focus on breast cancer, we will generate data frames only containing cell lines which are referable to this specific type of tumor. To make it simple we just rename our columns after the tumor disease. After that, we can subset the dataframe easily in breast cancer dataframes.

```{r echo=TRUE}
#Changing colnames to specific type of tumor:
pdata <- lapply(1:(length(dt_new)-1), function(a) {
  dat_picker <- dt_new[[a]] #pick one file at each iteration 
  col_names <- colnames(dat_picker) #extract the original column names
  annotation_new <- data$annotation[which(col_names %in% data$annotation$DepMap_ID),4] #get sample names in the order of the col_names list
  colnames(dat_picker) = annotation_new #rename the columns
  return(dat_picker)
})
names(pdata) <- names(data)[which(names(data) %!in% c("mutation", "annotation"))] #rename the data
lapply(pdata, dim) #look if the renaming worked
lapply(pdata, head) #look if at the data

#Generating 4 dataframes, containing just breast cancer cell lines (BCCL)
BCCL_kd.ceres = pdata$kd.ceres[,which(colnames(pdata$kd.ceres) == sample_case)]
BCCL_Expression = pdata$expression[,which(colnames(pdata$expression) == sample_case)]
colnames(BCCL_Expression) <- samples #IDs as colnames are needed later
BCCL_Mutation = lapply(ids, function(a) mut[[a]])
names(BCCL_Mutation) = samples #IDs as names are needed later
BCCL_Annotation <- subset(data$annotation, Primary.Disease == sample_case)
tPatients_ID <- t(BCCL_Annotation[1]) #create a vector of patientIDs useful for the MutImpact Matrix
#Reminder to myself: create another command, to reorder rows alphabetically (for loops are not working)
```

### Exploring gene expression patterns 

The next step was to do some experiments, in order to get a feeling for data distribution. 
We made a heatmap of expression values as well as CERES scores and found a diverse an unordered expression of genes trough the 28 breast cancer cell lines. Somehow, within the CERES scores were genes, a group of genes was showy, having a clear negative effect on cell viability. This group is suggested to be so called "housekeeping-genes", genes fulfilling the essential roles in cellcycle. All the other genes showed a large variety of through the cell lines, giving us a clue how useful our computer based approach might be. To make shure we can use all cell lines, we investigated if some of the cell lines shows abnormal values in comparison to others. The boxplot below proofs, this is not the case. 

```{r echo=TRUE, fig.align= "center"}
#Create a heatmap for all Genes and their CERES score
CERES50 <- as.matrix(BCCL_kd.ceres[c(1:nrow(BCCL_kd.ceres)),c(1:28)])
col <- colorRampPalette(c("seagreen3", "white", "red2"))(n = 1000) #defining the colours for the heatmap
CERESHeatmap <- heatmap.2(CERES50, scale = "none", col = col, 
          trace = "none", density.info = "none", dendrogram = c("none"), labRow = FALSE, labCol = FALSE, main = "CERES scores of all BCCLs", xlab = "Breast cancer cell lines (BCCL)", ylab = "Genes, ordered by hierarchical clustering")
```

```{r echo=TRUE, fig.align= "center"}
# expanding the colourpalette to 28
nb.cols <- 28 
newcolours <- colorRampPalette(brewer.pal(8, "Paired")) (nb.cols)
#Plotting gene expression of all 28 BCCLs
GeneralExp <- BCCL_Expression[c(1:28),]
GenExmelt= melt(GeneralExp)
GeneralExp_boxplot = ggplot(GenExmelt, aes(x = variable, y = value)) +
     geom_boxplot(aes(fill=variable), outlier.alpha = 0.7,
                outlier.colour = "grey", outlier.shape = 20, outlier.size = 2) +
     labs(title = 'General expression in all 28 BCCLs', x = 'Breast cancer cell lines', y = 'Expression [TPM]') +
     theme_minimal() +
     geom_jitter(width = 0.15) +
     scale_fill_manual(values = newcolours) +
     theme(legend.position ='none',
           plot.title = element_text(hjust = 0.4),
           axis.text.x = element_blank(),
           legend.title= element_blank(),
           axis.title.x = element_text(),
           strip.text.y = element_text(angle = 0))
GeneralExp_boxplot
```

An issue was the very low level of expression of most genes, seen in the graph above. We discussed the possibility of erasing an amount of these genes and decided to not cut out any data, before we don't know  which kind of data we will need in the end. In this phase of the project is was open if a second site target will have a high expression in every case. 
As next step we made some tests, using driver mutations suggested in literature. These boxplots show the different roles of genes ending up in various expression values in a nice way. 

```{r echo=TRUE, fig.align= "center"}
GOI_Exp_lit <- BCCL_Expression[c("MYC", "PTEN", "TP53", "PIK3CA", "GATA3", "BRCA1", "BRCA2", "RB1", "GANAB", "PRKCSH", "RNF43"),]
Exp_lit_driver_mut= melt(GOI_Exp_lit)
Exp_lit_driver_mut$variable=rep(c("MYC", "PTEN", "TP53", "PIK3CA", "GATA3", "BRCA1", "BRCA2", "RB1", "GANAB", "PRKCSH", "RNF43"), ncol(GOI_Exp_lit))

Exp_lit_boxplot = ggplot(Exp_lit_driver_mut, aes(x = variable, y = value)) +
     geom_boxplot(aes(fill=variable), outlier.alpha = 0.7,
                  outlier.colour = "grey", outlier.shape = 20, outlier.size = 2) +
     labs(title = 'Expression values of driver mutations, derived from literature', x = 'The eleven most prevalent driver mutations in BC', y = 'Expression [TPM]') +
     theme_minimal() +
     geom_jitter(width = 0.2) +
     scale_fill_brewer(palette = "Paired") +
     theme(legend.position ='none',
           plot.title = element_text(hjust = 0.4),
           axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
           legend.title= element_blank(),
           axis.title.x = element_blank(),
           strip.text.y = element_text(angle = 0))

Exp_lit_boxplot
```

We already discarded some of this genes, mostly because they are known as tumor suppressor genes. In our approach we looked for targets, which show similar characteristics in cell viability after a knockdown. A knockdown of a tumor supressor gene, even if it is mutated, will rarely have a negative effect on cell viability. This makes genes associated with tumor supressor genes useless for an inhibitory drug and therefore not appropriate for our analysis. 

### Generation of the mutImpact matrix

Suggestion: Every mutation has an impact on cell viability. In our analysis we have to distinguish not only between single mutations, we also have to evaluate different mutations in our cell lines "working together" and making every cell line different in its chcaracteristics. In order to gain an overview of these characteristics, we will generate a matrix, showing the effect on viability, caused by a single mutation, in every cell line. 

Erase: In order to gain an overview of the effects on viability of each mutation present in one cell line the mutImpact matrix was generated.

Therefore, the BCCL_kd.ceres matrix containing CERES scores for all genes in breast cancer cell lines was used as a template and the cell line IDs were added as column names creating a pre_mutImpact matrix. An empty matrix was generated comprising 17634 rows and 28 columns matching the number of genes per cell line and the number of breast cancer cell lines, respectively. 

Subsequently, CERES scores of genes, which were not mutated in a given cell line, were replaced with "NA" by implementing an "if statement". This statement included the enquiry whether the gene ID is present in the list of mutated genes of a considered cell line as and in case the condition was met the CERES score was maintained. If "FALSE" was returned, the CERES score of the gene was replaced with "NA" for the considered cell line.

```{r, warning=FALSE}
#Generate pre_mutImpact matrix containing all CERES values and with IDs as colnames
pre_mutImpact <- BCCL_kd.ceres
colnames(pre_mutImpact)<-tPatients_ID

#generate empty mutImpact matrix
mutImpact <- matrix(, nrow = 17634, ncol = 28)
colnames(mutImpact)<-colnames(pre_mutImpact)
rownames(mutImpact)<-rownames(pre_mutImpact)

#fill mutImpact matrix with values
for (j in 1:ncol(pre_mutImpact)){
  lineID <- colnames(pre_mutImpact)[j] #select a column-name = cell line
  for (i in 1:nrow(pre_mutImpact)){
    GOI <- rownames(pre_mutImpact)[i] #select a gene
    if (GOI %in% BCCL_Mutation[[lineID]]$Hugo_Symbol){
      mutImpact[i, j] <- pre_mutImpact[i, j]
    } else {
      mutImpact[i, j] <- NA
    }#replace CERES value with NA in case the gene is not mutated
  }
}

#have a look at the mutImpact matrtix
head(mutImpact)
```

## Selection of driver mutations

### Identification of driver mutations using k means clustering of CERES scores 

In order to verify our selection of driver mutations from literature research, k means clustering of CERES scores was performed. Suitable driver mutations were expected to be found in the same cluster based on scaled CERES scores.

K means clustering was performed with all genes mutated at least once in  28 cell line samples and whose CERES score is not greater than zero. For this, all genes with only NA values (hence, not mutated in the `MutImpact Matrix`) were removed. A new dataframe `BCCL_kd.ceres_2`was generated containing all 28 CERES scores for each gene, with gene names in the first column. These names were compared to the rownames of `mutImpact_c` to generate the `BCCL_kd.ceres_3` dataframe. The resulting dataframe contains CERES scores of all genes mutated at least once for each breast cell cancer lines. Subsequently, the average mean CERES score for each gene was computed using the `rowMeans` function and stored in the last column. To carry out this step, the column `rownameskdc2` was removed. Finally, all genes with CERES scores > 0 were deleted. The final `BCCL_kd.ceres_3` dataframe consisted of 4934 genes mutated at least once in the 28 breast cancer cell lines and with CERES scores equal to or below 0. 

```{r}
# selecting only genes mutated at least once and with Ceres <= 0
mutImpact_c = mutImpact[rowSums(is.na(mutImpact)) != ncol(mutImpact),]# remove all genes with all NA values
rownamesmutImpc = rownames(mutImpact_c)
mutImpact_c = cbind(rownamesmutImpc, mutImpact_c[,2:ncol(mutImpact_c)]) # insert new column with row names
dim(mutImpact_c) # check gene reduction 
rownameskdc2 = rownames(BCCL_kd.ceres) # define vector of BCCL_kd.ceres rownames 

BCCL_kd.ceres_2 = cbind(rownameskdc2, BCCL_kd.ceres[,2:ncol(BCCL_kd.ceres)]) # insert new column with row names
BCCL_kd.ceres_3 = BCCL_kd.ceres_2[BCCL_kd.ceres_2[,"rownameskdc2"] %in%  mutImpact_c[,"rownamesmutImpc"],][,-c(1)]
BCCL_kd.ceres_3 = cbind(BCCL_kd.ceres_3, rowMeans(BCCL_kd.ceres_3))[rowMeans(cbind(BCCL_kd.ceres_3, rowMeans(BCCL_kd.ceres_3)))<= 0,] # deletion of genes with CERES > 0
dim(BCCL_kd.ceres_3)
```

In preparation of k means clustering, the column containing average CERES scores for each gene was removed (new dataframe `BCCL_kd.ceresKS`) and the optimal number of k clusters identified. For each column (cell sample) of the dataframe, the data values were scaled. For cluster numbers between 2 and 15 the within sum of squares for each cell sample was calculated and stored as a separate dataframe. To ensure that the same result is obtained each time the code is run, the set.seed(1234) function was used.  

```{r warning=FALSE}
#determining optimal cluster number k
BCCL_kd.ceresKS = BCCL_kd.ceres_3[,-c(28)] # remove column of average CERES value column 

CERES_Optimal_K <- function(BCCL_kd.ceresKS, specifier) {
  output <- lapply(1:ncol(BCCL_kd.ceresKS), function(a){
   df <- scale(BCCL_kd.ceresKS[,a]) # pick one column of input data and scale 
   wss <-(nrow(df-1))*sum(apply(df,2,var)) #define method of wss computation 
   for (i in 2:15){ # for k between 2 and 15
     set.seed(1234) # to ensure reproducability of results 
     wss[i] <- sum(kmeans(df, centers = i)$withinss)
     } 
   return(wss)
  })
names (output) <- colnames(BCCL_kd.ceresKS) # rename the output 
return(output)
}

BCCL_kd.ceres_optKS <- CERES_Optimal_K(BCCL_kd.ceresKS, "CERES Optimal Clusters k") 
```

To enable the plotting of within sum square (WSS) values for clusters from 2 to 15 for each breast cancer cell, each vector was individually picked and formatted into a dataframe. The cell sample name was then added as a label in a new column "Cell_Sample" and the cluster numbers from 2 to 15 in the column "OptimalK".
The output of this lapply function (`optimalKprocessedData`), a list of 28 dataframes, was then combined into one and columns renamed accordingly. Subsequently, the ggplot function was used to plot all data stored in `optimalKprocessedData` in one plot. 

```{r fig.align="center"}
# plotting wss function 
optimalKprocessedData <- lapply(seq_along(BCCL_kd.ceres_optKS), function(a){
  dtPicker <- as.data.frame(BCCL_kd.ceres_optKS[[a]]) # one vector picked and formatted into dataframe
  dtPicker$Cell_Sample <- names(BCCL_kd.ceres_optKS)[a] #sample added as label
  dtPicker$OptimalK <- 1:nrow(dtPicker) 
  return(dtPicker)
})

optimalKprocessedData <- as.data.frame(do.call("rbind",optimalKprocessedData)) # output into dataframe
colnames(optimalKprocessedData) <- c("WSS", "Cell_Sample", "OptimalK") # renaming columns

# using ggplot to plot output 
ggplot(data = optimalKprocessedData, aes(x=OptimalK, y=WSS)) +
  geom_line(aes(color=Cell_Sample)) +
  labs(title = 'Optimal number of clusters k', x = 'Number of clusters', y = 'WSS') +
  theme_minimal() +
           theme(legend.position ='bottom',
                  plot.title = element_text(hjust = 0.5),
                  axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
                  legend.title= element_blank(),
                  axis.title.x = element_blank(),
                  strip.text.y = element_text(angle = 0))
```

From this plot it is evident that the optimal cluster number, when applying the elbow method, lies between 2 and 4. To verify this result and to determine a precise number of optimal cluster, an alternative plotting method calculating the average WSS for cluster numbers between 2 and 15 for all 28 cell samples was performed. 

```{r warning=FALSE, fig.align="center"} 
# Verification of optimal number of clusters k 

km_CERES= kmeans(x = BCCL_kd.ceres_3, centers = 2, nstart = 10)
table(km_CERES$cluster)
wss = sapply(2:15, function(k) {
    kmeans(x = BCCL_kd.ceres_3, centers = k)$tot.withinss
})
plot(2:15, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares") 
```

The optimal cluster number k was identified to be 4. Thus k means clustering of the data stored in `BCCL_kd.ceres_3` was performed with 10 iterations. The following cluster plot was generated.

```{r fig.align="center" }
km_CERES= kmeans(x = BCCL_kd.ceres_3, centers = 4, nstart = 10)
table(km_CERES$cluster)
fviz_cluster(km_CERES, data=BCCL_kd.ceres_3, labelsize = 6) # plotting clusters
```

In order to verify our selection of driver mutations from literature, the cluster number of each driver mutation was identified. All selected driver mutations from literature,"ERBB2", "MYCBP", "PARP10" and "PIK3CA" were colocalized in cluster 3, hence with similar CERES scores, with the exception of "CCND" and "ERBBIP". While "CCND" was removed in the filtering process and no longer found in`BCCL_kd.ceres_3`, "ERBB2IP" was found in cluster 4. For these reasons the two mentioned mutations were excluded from further analysis, to leave only "ERBB2", "MYCBP", "PARP10" and "PIK3CA" as selected driver mutations.

```{r}
km_CERES$cluster["ERBB2"] #obtaining cluster number for each driver mutation from literature # do you think it is possible to do this in a loop ?
km_CERES$cluster["ERBB2IP"]
km_CERES$cluster["MYCBP"]
km_CERES$cluster["PARP10"]
km_CERES$cluster["PIK3CA"] 
```

Since our approach defined SSTs as genes expected to interact synergistically with the corresponding driver mutation in promoting cell viability, similar CERES scores were expected. Thus all potential SSTs candidates were expected to be found in cluster 3 as well. A dataframe `data_clus_3`was subsequently generated to contain all 1148 genes colocalized with driver mutations in cluster 3. 

```{r}
data_cluster = as.data.frame(km_CERES$cluster)
rownames(data_cluster) = rownames(BCCL_kd.ceres_3)
data_clus_3 = BCCL_kd.ceres_3[data_cluster == 3,] #dataframe with all 1148 genes in same cluster as driver mutations 
```

A further dataframe `data_clus_3e` was subsequently generated labelling the four driver mutations in a separate column, by implementing an "IF" loop. If the rowname of `data_clus_3e`was found in a previously created vector containing driver mutations names (`drivermut`), it was labelled as "driver mutation". Otherwise genes were labelled as "no driver mutation".

```{r Labeling driver mutations}
drivermut =  c("ERBB2","MYCBP", "PARP10", "PIK3CA") # create vector with driver mutation names

data_clus_3e = data_clus_3
data_clus_3e["Driver mutation"] <- sapply(1:nrow(data_clus_3), function(j){
     if(rownames(data_clus_3e)[j] %in% drivermut){ 
         data_clus_3e[j,1] = "driver mutation"
     } else {
         data_clus_3e[j,1] = "no driver mutation"
     }
  }) # labeling driver mutations with "driver mutation" in data_clus_3e 
```

### Data visualisation of CERES and TPM values for selected driver mutations 

CERES scores and expression in TPM values for the selected 4 driver mutations were visualised as box and whisker plots. Following the generation of the `GOI_X` dataframe containing either CERES or TPM values for the four mutations, the data was reshaped to contain two columns. One column being "variable" with the names of driver mutations, the other "value" with the corresponding CERES or TPM value. The ggplot function, part of the ggplot2 package, was used to plot the following box an whisker plots. 

```{r data visualisation, fig.align = 'center', warning=FALSE}

# CERES_boxplot
GOI= BCCL_kd.ceres[c("ERBB2","MYCBP", "PARP10", "PIK3CA"),]
CERES_driver_mut= melt(GOI)
CERES_driver_mut$variable=rep(c("ERBB2","MYCBP", "PARP10", "PIK3CA"), ncol(GOI)) # replication of driver mutation names as often as number of GOI columns

CERES_boxplot = ggplot(CERES_driver_mut, aes(x = variable, y = value)) +
       geom_boxplot(aes(fill=variable), outlier.alpha = 0.7,
                     outlier.colour = "grey", outlier.shape = 20, outlier.size = 2) +
        labs(title = 'CERES scores of selected driver mutations', x = 'Selected driver   mutations', y = 'CERES scores') +
            theme_minimal() +
            geom_jitter(width = 0.2) +
            scale_fill_manual(values = wes_palette("Royal2", n=4)) +
            theme(legend.position ='none',
                  plot.title = element_text(hjust = 0.4),
                  axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
                  legend.title= element_blank(),
                  axis.title.x = element_blank(),
                  strip.text.y = element_text(angle = 0))
CERES_boxplot

  
#Expression_boxplot
GOI_Exp= BCCL_Expression[c("ERBB2","MYCBP", "PARP10", "PIK3CA"),]
Expression_driver_mut= melt(GOI_Exp)
Expression_driver_mut$variable=rep(c("ERBB2","MYCBP", "PARP10", "PIK3CA"), ncol(GOI_Exp))

Expression_boxplot = ggplot(Expression_driver_mut, aes(x = variable, y = value)) +
       geom_boxplot(aes(fill=variable), outlier.alpha = 0.7,
                     outlier.colour = "grey", outlier.shape = 20, outlier.size = 2) +
        labs(title = 'Transcripts per million (TPM) of selected driver mutations', x = 'Selected driver mutations', y = 'Transcripts per million (TPM)') +
            theme_minimal() +
            geom_jitter(width = 0.2) +
            scale_fill_manual(values=wes_palette("Royal2", n=4)) +
            theme(legend.position ='none',
                  plot.title = element_text(hjust = 0.4),
                  axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
                  legend.title= element_blank(),
                  axis.title.x = element_blank(),
                  strip.text.y = element_text(angle = 0))
Expression_boxplot
```

The box- and whisker plot of CERES scores reveal the MYCBP mutations as the most essential driver mutations for cell survival. This gene is followed by PIK3CA and PARP10 mutations. While ERBB2 has the highest average CERES scores and hence lowest impact on cell proliferation, this mutation exhibits the largest spread of values across 28 breast cell cancer lines, reaching the overall minimum value of -1. The interquartile range of CERES scores for both MYCBP and PARP10, are the lowest, indicating a consistent impact of gene knockouts on cell sample survival. Also interesting is the large interquartile range of the PIK3CA mutation, with data points found in two clusters, one around -0.15 and the other between -0.5 and -0.9. 

While the ERBB2 driver mutation was found to have the lowest essentiallity for cell survival on average, mean TPM values are shown to be highest, suggesting overexpression. Once again TPM values for this mutation have the largest spread, reaching more than 11.5 TPM. This implies the greatest variation overall in data for the ERBB2 driver mutation. Like for the CERES scores, both MYCBP and PIK3CA have a small interquartile range, while ranges for PARP10 are markedly larger. Further, it is interesting to note despite two CERES score data clusters for PIK3CA, TPM values show little variation around the mean. 

## Identification of second-site targets

### Spotting genetic interactions: the Wilcoxon test

Genetic interactions of driver mutations with other genes were examined based on a Wilcoxon signed rank test. As SSTs are expected to interact synergistically with the corresponding driver mutation in promoting cell viability similar CERES scores are suggested to infer the presence of gene interactions. Thus, high p-values are anticipated for such cooperating gene pairs when performing the Wilcoxon signed rank test. The Wilcoxon signed rank test was chosen rather than a t-test due to non-normal distribution of the data and the requirement of a paired test to compare the data of two genes per cell line. Assuming that the ranks of the CERES scores of the driver mutation and their SSTs are equa,l SST candidates were chosen by the means of the highest p-values (accepting the H0 hypothesis).

For the purpose of conducting the Wilcoxon test the data from which the CERES scores for the test are taken was prepared. Therefore, a vector containg the identified driver mutations was generated. Furthermore, a reduced mutImpact matrix `mutImpact_r` was created from `mutImpact`which only includes genes which are mutated and do not have `NA`values only. Based on `mutImpact_r`the `BCCL_kd.ceres` matrix was reduced resulting in the `mutImpact_kd.ceres` matrix containing the CERES scores of all genes in all cell lines if the gene is mutated in one cell line at minimum. 
*question: I created exaclty the same matrix  little bit further up in the code. Perhaps there is no need to recreate a new dataframe here?*

```{r}
#preparation of the data
driver_mut <- c("ERBB2","MYCBP", "PARP10", "PIK3CA") #enter driver mutations
mutImpact_r <- mutImpact[rowSums(is.na(mutImpact)) != ncol(mutImpact), ] #_r=reduced: get rid of all the ONLY NA rows (this will save computation)
mutImpact_kd.ceres <- BCCL_kd.ceres[rownames(BCCL_kd.ceres) %in% rownames(mutImpact_r),] # create matrix containing CERES scores of genes which are mutated once at minimum
colnames(mutImpact_kd.ceres) <- tPatients_ID
```

A Wilcoxon signed rank test was performed for every driver mutation with all other mutated genes and the data was stored in a list comprising one data frame with the obtained p-values for each driver mutation. 

Thereupon, a loop was installed generating the output data frame for each driver mutation. At first the driver mutation to be examined was selected and the corresponding CERES values retrieved from `mutImpact_kd.ceres` being saved in the temporary variable `driverMutData`. Consequently, a reference gene was chosen and the CERES scores of the reference gene was stored in another temporary vector `refGeneData`. In case the selected reference gene was not the driver mutation itself the Wilcoxon test was performed. The p-value of each gene pair was saved in the data frame of the considered driver mutation.

```{r}
#performance of the Wilcoxon test
testData <- lapply(seq_along(driver_mut), function(a) {
  driverMutPicker <- driver_mut[a] #pick a driver mutation
  driverMutData <- mutImpact_kd.ceres[driverMutPicker,] #get CERES scores of driver mutation
  
  outputData <- sapply(1:nrow(mutImpact_kd.ceres), function(b) {
    refGeneData <- mutImpact_kd.ceres[b,] #get CERES scores of reference gene (potential SST)
    
    if (rownames(refGeneData) != driverMutPicker) {
      out <- wilcox.test(as.numeric(driverMutData), as.numeric(refGeneData), paired = TRUE)$p.value #get p-value of wilcoxon signed-rank test
      out <- as.data.frame(out, rownames(mutImpact_r)[b]) 
      return(out)
    }
  })
  test = do.call(rbind, outputData)
  rownames(test) <- rownames(mutImpact_r)[which(rownames(mutImpact_r) != driverMutPicker)]
  return(test)
})
names(testData) <- driver_mut

lapply(testData, function(a) head(a)) #look at the data
```

As the null hypothesis claims that the CERES scores of the driver mutation and the reference genes are equal, low p-values indicate that there is no relation between the CERES scores of the driver mutation and the reference gene whereas high p-values may allude to genetic interaction of the driver mutation with an SST.
The obtained p-values were distributed as shown below. Most strinkingly, the first quantile was set at a p-value of 0.0 for each driver mutation, indicating that there are many genes with CERES scores which are not relatable to the CERES scores of the driver mutations. However, the maximum p-value of each test constituted 1.0 suggesting that there are also genes with similar CERES scores as the driver mutations which are supposed to be the SSTs. 

```{r}
#get summary of distribution
summary(testData$ERBB2)
summary(testData$MYCBP)
summary(testData$PARP10)
summary(testData$PIK3CA)
```

Based on the results of the Wilcoxon test, potential SSTs were chosen by means of the highest p-values. Thus, the list `SST_Data`consisting of one data frame per driver mutation was created based on the test results given in the `test_data` list. Therefore, an `lapply`command was used filtering each data frames of `test_data` by selecting the 15 reference genes which were found to have the most similar CERES scores as the driver mutation, indicated by high p-values. In this course, the rownames of the data frames had to be transferred to an extra column before selection and transferred back afterwards as otherwise the rownames would have been lost during the filtering process. Unequal numbers of SST candidates were found due to similar test results for several reference genes.

```{r}
#select 15 most promising SST candidates based on highest p-values

SST_Data <- lapply(seq_along(testData), function(a) {
  data <- as.data.frame(testData[[a]], col.names = names(testData[[a]])) #create new data frame containing testData for each SST
  colnames(data) = driver_mut[a] #rename columns
  data <- data %>%rownames_to_column() %>% top_n(15, data[,1]) %>% column_to_rownames() #select 15 genes with highest p-value
  return(data)
})
names(SST_Data) <- driver_mut

#have a look at the SST candidates
head(SST_Data)
```

### Verification of SST candidates by assigned k means cluster number 

After selection of the SST candidates stored in `SST_Data` the coexsitance of SST candidates and driver mutation in the same k means cluster was verified. An assignment to the same cluster would confirm a possible cooperation of gene pairs due to similar CERES scores. For this, the lapply function was used to chose each dataframe and thus driver mutation in turn from the list using the seq_along command.A further loop was installed such that for each driver mutation dataframes, the rownames of the `DvPicker` were compared to all possible  `data_clus_3e` rownames. If a coexistance of genes in the 3rd k means cluster was identified, genes were labelled as `verified` in a new column entitled "classifier". No match between rownames led to the `not verified`entry.

```{r SST Cluster Check}
SST_Data <- lapply(seq_along(SST_Data), function(a) { # pick one dataframe from list
  DvPicker <- SST_Data[[a]] # choose DV 
  
  DvPicker$classifier <- sapply(1:nrow(DvPicker), function(b) {
    if (rownames(DvPicker)[b] %in% rownames(data_clus_3e)) {
      DvPicker[b, 2] <- "verified"
    } else {
      DvPicker[b, 2] <- "not verified" 
    }
  })
  return(DvPicker)
})
names(SST_Data) <- driver_mut
```

### Characterization of second-site targets

In order to characterize the SSTs, additional information on each SST was retrieved from the original data set and added to the data frames in `SST_Data`.

First, the type of mutation was examined for each SST and each cell line in which it was mutated. For this purpose a nested `lapply`construction was used. Initially, a data frame of one driver mutation was chosen and the new column `mutType` was generated by the second `lapply`loop. Thus, iterating the SST candidates the mutation status of each SST in each cell line was determined inspecting the presence of the SST in the list of mutated genes for each cell line. If the SST candidate was mutated in a given cell line its type of mutation (stored in the `BCCL_Mutation`list as `Variant_Classification`) was obtained and saved in a temporary vector to which all possible types of mutations were collected for each SST. Finally, this vector was concatenated as a string, which was assigned to the `mutType` column.

```{r}
SST_Data <- lapply(seq_along(SST_Data), function(a) {
  dvPicker <- SST_Data[[a]]#pick a data frame of one driver mutation
  
  dvPicker$mutType <- sapply(seq_along(rownames(dvPicker)), function(b) {
    SSTPicker <- rownames(dvPicker)[b]#select an SST candidate
    
    mutTypeData <- c()
    for (i in 1:ncol(BCCL_kd.ceres)) { 
      if (SSTPicker %in% BCCL_Mutation[[i]]$Hugo_Symbol) { #check whether the SST mutation is present in a cell line
        out <- BCCL_Mutation[[i]]$Variant_Classification[a] #get type of mutation per SST and cell line
        mutTypeData <- c(mutTypeData, out) #store type of mutation in vector
      }
    }
    dvPicker[b, 2] <- paste(mutTypeData, collapse = ", ") #create a string of SST mutation types based on the vactor
  })
  return(dvPicker)
})
names(SST_Data) <- driver_mut
```

Furthermore, the physiological gene function of every SST candidate was investigated using the universal protein database (UniProt). Therefore, a table was prepared for every DV using Microsoft Excel in order to document the findings from literature research and saved as a `.csv`file. Consequently, the Excek files were imported to R as data frames from which the list `functionTable` was created. This list was used as a template to add information on the gene function to `SST_Data` by iteratively appending the column `function` of the `functionTable` data frames to the corresponding data frame in the `SST_Data` list.

Most strikingly, many of the SST gene functions comprise proteins contributing to cell cycle progression, cell motility and polarity as well as transcriptional regulators affecting cell metabolism. This supports the hypothesis that alterations in gene activity of the STTs promote cancer progression.

```{r warning=FALSE, error=FALSE}
functionTable <- list(
read_delim(paste0(root.dir,"/functionTable_ERBB2.csv"), ";", escape_double = FALSE, col_names = TRUE, trim_ws = TRUE),  read_delim(paste0(root.dir,"/functionTable_MYCBP.csv"), ";", escape_double = FALSE, col_names = TRUE, trim_ws = TRUE), read_delim(paste0(root.dir,"/functionTable_PARP10.csv"), ";", escape_double = FALSE, col_names = TRUE, trim_ws = TRUE), read_delim(paste0(root.dir,"/functionTable_PIK3CA.csv"), ";", escape_double = FALSE, col_names = TRUE, trim_ws = TRUE)) #create list of data frames containing the data of the Excel files (e.g. gene function, references)

SST_Data <- lapply(seq_along(SST_Data), function(a) {
  SST_Data[[a]] <- cbind(SST_Data [[a]], as.data.frame(functionTable[[a]]["function"])) #add gene function for every SST of every DV
})

names(SST_Data) <- driver_mut #regenerate names

show(SST_Data$ERBB2)
show(SST_Data$MYCBP)
show(SST_Data$PARP10)
show(SST_Data$PIK3CA)
```

## Exploiting interactions: Regression analysis to predict CERES scores of driver mutation

For the regression model, we want to predict the CERES score of the driver mutation (dependent variable) based on the CERES score of the SST candidates (independent variables).

### Conditioning the dataset

To run Multilinear regression, we reform the `BCCL_kd.ceres` matrix. By transponing and format change, we obtain a matrix with colnames = Gene names and rownames = Cell line indices (equal to tPatients_ID). Then, we collect the relevant the CERES scores for the mutations for the linear regression.
All columns with the corresponding names of the SST genes plus the driver mutation will be collected and copied into a new dataframe.
      
```{r Regression sample construction fig.align = 'center', warning=FALSE}
#reformat BCCL CERES matrix
BCCL_kd.ceres_df <- as.data.frame(t(BCCL_kd.ceres))
rownames(BCCL_kd.ceres_df) <- tPatients_ID
colnames(BCCL_kd.ceres_df) <- rownames(BCCL_kd.ceres)

#generate a dataframe containing data for each DV
linRegData_ERBB2 <- BCCL_kd.ceres_df %>% select(rownames(SST_Data$ERBB2), "ERBB2")
linRegData_MYCBP <- BCCL_kd.ceres_df %>% select(rownames(SST_Data$MYCBP), "MYCBP")
linRegData_PARP10 <- BCCL_kd.ceres_df %>% select(rownames(SST_Data$PARP10), "PARP10")
linRegData_PIK3CA <- BCCL_kd.ceres_df %>% select(rownames(SST_Data$PIK3CA), "PIK3CA")

data_regression <- list(linRegData_ERBB2, linRegData_MYCBP, linRegData_PARP10, linRegData_PIK3CA)
names(data_regression) <- c("ERBB2", "MYCBP", "PARP10", "PIK3CA")
```

To run regression, certain conditions must be fulfilled:
Normal distribution, checked with a qqPlot:Using the aes-function for aesthetic plots, provided by the "ggplot2" package.
Multicollinearity, which is given if two dependent variables are strongly correlated, which can lead to difficulties in further analysis.
    + As rule of thumb, the Pearson correlation coefficient should be lower than 0.8:
      $r < 0.80$
If this requirement is not met, one of the correlated variables should be deleted as it is seen as redundant.

```{r Regression sample distribution fig.align = 'center', warning=FALSE}
lapply(seq_along(data_regression), function(a){  
  p <- ggplot(data_regression[[a]], aes(sample=data_regression[[a]][,ncol(data_regression[[a]])], col = "red")) + stat_qq()+ stat_qq_line() #create qq-Plot with line for comparison to normal distribution
   p + labs(title = "QQ-Plot", subtitle = "Check if data is approx. normally distributed")
  
  r <-  round(cor(data_regression[[a]]),2) #create table with correlation values between all SSTs; the values are rounded to two decimal places [,2)]
  
  return(list(p,r))
   })
```
Quick Results: The Data of MYCBP and PARP10 is approx. normally distributed; ERBB2 and PIK3CA not. No multicollinearity detected, all 0.80 > x
  
### Design of the multilinear regression

To run the Multilinear Regression, it is advised to create a long function which splits the dataset in __75:25__ training:test data. (Previous installation of the "caTools" package is necessary)
Then the function conducts Training of Regression model with training data to predict Driver mutation CERES (y; dep.variable) from SST CERES scores (x1 ... xn; indep.variables)
Followed by checking model assumptions of residual normal distribution and homoscedasticity.
Later on, the function runs the test Data on model for performance evaluation and finally calculates and plots Spearman correlation to further asses model performance.
```{r Multiple Regression function fig.align = 'center', warning=FALSE}
input_data <- data_regression

plottingData <- lapply(seq_along(input_data), function(a) {
  set.seed(123) #initialize the random numbers, ensures better repoducibility
  data <- input_data[[a]] #get the data
  colnames(data)[length(colnames(data))] <- "Predictor"
  
  split = sample.split(data[,ncol(data)], SplitRatio = 0.75) #split the dataset into 3/4 Training and 1/4 Testing dataset
  training_set = subset(data, split == TRUE) #use the labels to get the training data
  test_set = subset(data, split == FALSE)
  
  regressor = lm(formula = Predictor ~ ., 
                 data = training_set)  #predict CERES of Driver Mutation based on all (=.) the input variables (SSTs)
  
  pdf(paste0(root.dir, "/Resid-HomoPlot_",driver_mut[a],".pdf")) #save plots as pdf, in working directory "wd"
  hist(resid(regressor), main = paste0('Histogram of residuals: ', driver_mut[a]),xlab='Standardised Residuals',ylab='Frequency') #plot a histogram of standardised residuals to check the assumption of normality
  dev.off() #closing the figure file
  
  pdf(paste0(root.dir, "/HomoPlot_",driver_mut[a],".pdf")) #save plots as pdf, in working directory "wd"
  plot(regressor, which = 1) #fitted values and residuals plot to check the assumption of homoscedasticity
  dev.off() #closing the figure file
  
  y_pred = predict(regressor, newdata = test_set) #predict the Driver mut. CERES score based on the test data
  test_set$Prediction = y_pred #adding predictions to the dataset
  
  df = cbind(test_set$Predictor, test_set$Prediction)
  colnames(df) <- c("Predictor", "Prediction")
  rownames(df) <- rownames(test_set)
  
  return(df) #create a dataframe with predicted and observed CERES values
})

# Plot the data external 
plottingFunction <- function(inputData, driverMut) {
  df = melt(inputData)
  p <- ggplot(data = df, aes(x=value, fill=Var2)) + 
    geom_density(alpha=.3) +
    ggtitle(paste0("Spearman Correlation plot: ", driverMut)) +
    ylab("Predicted score") +
    xlab("Observed score") +
    theme_bw(base_size = 7) + #design input
    theme(legend.position="bottom",
          legend.direction="horizontal",
          plot.title = element_text(hjust = 0.5),
          axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),#design input
          legend.title= element_blank(),
          axis.title.x = element_blank(),
          strip.text.y = element_text(angle = 0))
  
  pdf(paste0(root.dir, "/SpearmanPlot",driverMut,".pdf"))
  print(p)
  dev.off()#closing the figure file
}

plottingFunction(plottingData[[1]], driver_mut[1])
plottingFunction(plottingData[[2]], driver_mut[2])
plottingFunction(plottingData[[3]], driver_mut[3])
plottingFunction(plottingData[[4]], driver_mut[4])

#Get the correlation values
correlations <- lapply(seq_along(plottingData), function(a) {
  df = plottingData[[a]]
  corVal <- cor.test(df[,1] , df[,2], method = "spearman") #to judge model performance, calculate Spearman corr. between predicted and observed values
  return(corVal)
})
names(correlations) <- driver_mut
correlations #look at the dat
```

*How about doing a linear regression model and comparing the F-statistic values?*

#Checking assumptions
All four models were tested on the assumptions. The following table provides a quick overview if our constructed assumptions was met (yes) or not (no). For multicollinarity, all models met the condition r < 0.8 for all variables.

Model     | Data distribution | Residual distribution| Homoscedastity |Spearman correlation |
----------|-------------------|----------------------|----------------|---------------------|
ERBB2     | no                | yes                  | no             | no                  |
MCYBP     | yes               | no                   | yes            | no                  |
PARP      | yes               | no                   | yes            | no                  |
PIK3CA    | no                | yes                  | no             | no                  |

Checking distributional assumptions (= normal distribution) is also important and a different model should be chosen if needed. (Harrell 2001). 
As shown in the qq-Plots, normal distribution does only apply to the models of MYCBP and PARP10. ERBB2 on the other hand, delivers the highest rho, but is in no way approx. normal distributed.The PIK3CA model also does not fulfill the condition of normal distribution.

The normal distribution does not lead to higher correlation coefficients. But not satisfying distribution assumptions should be treated as a red flag; and the model is not suited for further use.

The residual distribution of ERBB2 was closest to normal distribution. The PIK3CA residuals showed still acceptable approximation of normal distribution.
MYCBP and PARP10 failed to show approx. normal residual distribution.

Also known as homogeneity of variance, this condition is met if random variables have similar variance. Also, there is no pattern of variance change if the random variables in- or decrease. #citation
ERBB2 and PIK3CA violate the condition, while MYCBP and PARP10 show homoscedasticity.

# Interpreation
We obtained the following p-values and correlation coefficients:

Model     | p-value     | rho      | 
----------|-------------|----------|
ERBB2     | 0.8397      | 0.1071   |
MCYBP     | 0.7825      |-0.1429   |
PARP10    | 0.1095      |-0.6786   |
PIK3CA    | 0.7131      |-0.1786   |

The rank-correlation coefficient can take values from +1 to -1
    + rho ~ 1: perfect positive association of ranks
    + rho ~ 0: no association of ranks
    + rho ~ -1: perfect negative association of ranks

To further interprete the p-value, we construct a H0 / H1 hypothesis:
    + H0: There is no association between the predicted and observed variable.
    + H1: There is an association between the predicted and observed variable.
Most importantly, it is not possible to assess the strength of the correlation based on the p-value. It rather judges the statistical test than the resulting value. As default, we set the significance level to 0.05.

We will the compare this values for the different models. For a positive correlation, two variables move in the same direction. For a well-designed model, we expect the predicted and observed CERES scores being approx. even. Thus, optimal model design is achieved if the correlation coefficient is close to 1 and the p-value p < 0.05.

 The ERBB2-model shows the highest rho value of all four models, but ~ 0.1 is a rather weak positive relationship, but the p-value leads to __acceptance of H0_.

The rho value of the MYCBP-model leads to very weak negative correlation. A p-value of ~ 0.78 leads to confident acceptance of H0.

For the PARP10-model, the rho value of ~ -0.67 is a moderate negative relationship. The p-value leads to acceptance of H0. The p-value is the lowest with ~ 0.11. But even if we would raise the confidence level to 0.10 (which would be a questionable move in statistics), the result wouldn´t be significant to accept H1.
    
The rho value of the PIK3CA-model leads to very weak negative correlation. A p-value of ~ 0.78  leads to confident acceptance of H0.

The models for MYCBP and PIK3CA only showed weak, negative correlation, which is not useful for further work with this model.
The PARP10 model resulted in a moderate negative relationship, which is not of relevance for our objective.
The ERBB2 model did not deliver a significant p-value, but indeed contains at least a weak positive correlation.

#Discussion
__All in all, all multilinear regression models failed to meet all regression assumptions deliver a p-value of significant relevance for the correlation. Thus, they should not be used for further predictions.__
Especially the models for ERBB2 and PIK3CA should have been discarded, since not even the basic sample distribution is normally distributed.
It seems possible that the small sample size for the regression model lead to the lack of significant results, with only 28 events (CERES score observed in cell line) per predicting variable (SST gene).

But, a common thumb-rule for building a regression model is to calculate the _limiting sample size_:

 $p < \frac{m}{15}$
 
  + p: number of predictor variables
  + m: limiting sample size; for continuous response variables it is the  total sample size n

If this equation is fulfilled, the model is supposed to be reliable.(Harrell 2001)
In fact, this condition is true for all four models.

Our data seems to have an appropriate size for a basic regression model.
On the other hand, for the supervised machine learning process of the regression, sample sizes up to n = 50,000 are reported.(Libbrecht and Noble 2015) 
In general, more data will lead to improved data quality. Generally, scientists are advised to focus on obtaining and analyzing larger data sets instead of comparing different learning techniques on small training sets.(Banko and Brill 2001)

# Results and Discussion

The aim of this project was to identify genes, so called second site targets, which interact genetically with selected driver mutations to promote cell viability and proliferation in breast cell cancers, with the hope that these could be used as targets for more specific gene therapies. 

After selection of five non-tumor suppressor gene driver mutations (CCND, ERBB2, MYC, PARP10, PIK3CA) form literature, datasets were formatted to include only breast cancer cell lines. Subsequent, general data exploration revealed a large variety of CERES scores and expression values across both selected driver mutations and remaining genes of breast cell cancer lines. This proved the need to undertake further steps of data cleanup. Thus, in order to analyze only mutated genes, the mutImpact matrix was generated, containing CERES values only of mutated genes in a given cell line, otherwise with the entry for a given cell line being “NA”. Further data cleanup was performed by removing all genes which contained all “NA” values and whose mean CERES scores were greater than zero. Through this process, 4934 possible SST genes remained, fitting the criteria of being mutated and having a positive impact on cell viability. However, in this process genes with a nonuniform distribution or of CERES scores across cell lines or unique outliers distorting mean values could have been mistakenly removed.

With this foundation, the selection of driver mutations from literature research was verified by performing k means clustering of associated CERES scores. After calculation of within sum squares values for a range of cluster numbers, the optimal cluster number was identified to be four using the elbow method. Clustering revealed four out of five driver mutations to be colocalized in cluster three, hence having similar positive effects of improving the viability of breast cancer cells while not being tumor suppressor genes. These genes thus proved appropriate for further analysis. While CCND was removed early on in data clean up stages due to not being mutated in any breast cancer cell line, ERBB2IP on the other hand was found in cluster four instead. Since both genes did not match the criteria of driver mutations they were excluded from further analysis. Overall, it must however be noted that although the optimal cluster number was identified to be four, the cluster plot shows that clusters were not distinctly separated from one another. Alternative cluster numbers could therefore have resulted in a different assignment of driver mutations and consequently other results based on our selection method. 

Nevertheless ERBB2, MYCBP, PARP10 and PIK3CA were used as central driver mutations for further analysis. Box-and whisker plots of CERES scores revealed mutations of the MYCB gene to have greatest essentiality, with least variation, for cell survival. ERBB2 on the other hand had the highest average of CERES scores, greatest variation and lowest impact on cell proliferation. In contrast the ERBB2 driver mutation showed highest TPM values and hence suggested overexpression. The gene however remained the gene with greatest variation in values. TPM expression values were lowest for PIK3CA, with little variation which was also seen for MYCBP. 

Since our approach had defined SSTs to be genes expected to interact synergistically with the corresponding driver mutation in promoting cell viability, CERES values were expected to be similar to those of the corresponding driver mutations. Consequently, all 1171 genes colocalized in k means cluster 3 were regarded as potential SST candidates. In order to spot genetic interactions, the paired statistical Wilcoxon test was performed, given that data followed a non-normal distribution. As previously mentioned, SSTs were expected to have similar CERES values to driver mutations and were hence chosen by means of highest p-values (accepting the H0 hypothesis). Surprisingly, the first quantile was set at a p-value of 0.0 for each driver mutation, indicating that many genes had CERES score not relatable to the CERES cores of driver mutations. The maximum p-value of each test however constituted 1.0, suggesting that there were also genes with similar CERES scores to driver mutations. 

Based on the result of the Wilcoxon test, the top 15 genes with highest p-values for each mutation were chosen.  Due to some genes having the same p-value, ERBB2 and PARP10 were each selected to have 17 potential SST candidates, PIK3CA 18 potential candidates while MYCBP had 15 candidates.In the next step all potential SST candidates were verified, by checking their cluster assignment in the previously completed k means clustering. As expected, all SST candidates were confirmed to be found in in the same cluster 3 as the driver mutations. With this verification, all SSTs were characterized and labelled with mutation type and the physiological gene function using the universal protein database (UniProt). Most strikingly, many SST gene functions comprised proteins contributing to cell cycle progression, cell motility and polarity together with transcriptional regulators affecting cell metabolism. The most common type of mutation was a missense or silent mutation for SSTs of all driver mutations. *does this part need to be in more detail?*

The final step in this project was to exploit the identified interactions and design a regression model to predict CERES scores of driver mutations based on the SST candidate CERES scores. This would allow us to predict the impact of driver mutations on cell viability based on the effect of SSTs on breast cancer cell proliferation. After data preparation, the conditions of normality and multicollinearity were verified. While MYCBP and PARP10 CERES values were approximately normally distributed, ERBB2 and PIK3CA values were not, thus not meeting the criteria for a multilinear regression. Additionally, no multicollinearity was detected with all values smaller than 0.80.  Nevertheless, after training the model on 75% of the data, the multilinear regression was run and residual normal distribution and homoscedasticity, as conditions for a good model, were analyzed. While the residuals of ERBB2 were closest to a normal distribution, residuals of the PIK3CA model are still an acceptable approximate of a normal distribution. Interesting to note is that while MYCBP and PARP10, on the other hand, do not show a normal residual distribution they do meet the condition of homoscedasticity, unlike ERBB2 and PIK3CA. A further measure to evaluate the design of the model was the test of spearmen correlation. P-values of all driver mutations lead to the confident acceptance of the H0 hypothesis and hence the statement that there is no association between predicted and observed variable. Weak negative correlation was identified for the MYCBP and PIK3CA model compared to a moderate negative correlation for the PARP10-model. Surprisingly, the ERBB2-model with a rho-value of 0.1 shows a weak positive relationship. In summary it can thus be argued that these multilinear regression models are not effective in predicting the impact of driver mutations on cell viability. One possible reason for unfitting regression models could be the small sample size of only 28 events (breast cancer cell lines). Calculation of the limiting sample size however suggests that our data set has the appropriate size for a basic regression model. To improve data quality, especially for the supervised machine learning process, a larger data set is necessary for the construction of an appropriate model. It should also be considered, that CERES scores of SST candidates and driver mutations may have a nonlinear correlation, requiring different prediction models. 

### Literature
  + Aleskandarany, M. A., E. A. Rakha, M. A. H. Ahmed, D. G. Powe, E. C. Paish, R. D. Macmillan, I. O. Ellis and A. R. Green (2010). "PIK3CA expression in invasive breast cancer: a biomarker of poor prognosis." Breast Cancer Research and Treatment 122(1): 45-53.
  + Arnold, A. and A. Papanikolaou (2005). "Cyclin D1 in Breast Cancer Pathogenesis." Journal of Clinical Oncology 23(18): 4215-4224.
  + Barnes, B., K. Kraywinkel, E. Nowossadeck, I. Schönfeld, A. Starker, A. Wienecke and U. Wolf (2016). Bericht zum Krebsgeschehen in Deutschland 2016, Robert Koch-Institut.
  + + Banko, M. and E. Brill (2001). Scaling to very very large corpora for natural language disambiguation. Proceedings of the 39th Annual Meeting on Association for Computational Linguistics. Toulouse, France, Association for Computational Linguistics: 26-33.
  + Gabay, M., Y. Li and D. W. Felsher "MYC activation is a hallmark of cancer initiation and maintenance." Cold Spring Harbor perspectives in medicine 4(6): a014241.
  + Harrell, F. E. (2001). Regression modeling strategies : with applications to linear models, logistic regression, and survival analysis. New York ; Berlin ; Heidelberg [u.a.], Springer.
  + Hutchinson, L. (2010). "Challenges, controversies, breakthroughs." Nature Reviews Clinical Oncology 7: 669.
  + Koch-Institut, R. (2017). Krebs in Deutschland für 2013/2014, Robert Koch-Institut.
  + Kumar R (2016) A novel therapeutic target for triple negative breast cancer. Biomed Genet Genomics. 1: DOI: 10.15761/BGG.1000101.
  + Libbrecht, M. W. and W. S. Noble (2015). "Machine learning applications in genetics and genomics." Nature reviews. Genetics 16(6): 321-332.
  + Shimoi, T., A. Hamada, M. Yamagishi, M. Hirai, M. Yoshida, T. Nishikawa, K. Sudo, A. Shimomura, E. Noguchi, M. Yunokawa, K. Yonemori, C. Shimizu, T.   + Kinoshita, T. Fukuda, Y. Fujiwara and K. Tamura (2018). "PIK3CA mutation profiling in patients with breast cancer, using a highly sensitive detection system." Cancer science 109(8): 2558-2566.
  + Siraj, A. K., P. Pratheeshkumar, S. K. Parvathareddy, S. P. Divya, F. Al-Dayel, A. Tulbah, D. Ajarim and K. S. Al-Kuraya (2018). "Overexpression of PARP is an independent prognostic marker for poor survival in Middle Eastern breast cancer and its inhibition can be enhanced with embelin co-treatment." Oncotarget 9(99): 37319-37332.
  + Slamon, D., W. Godolphin, L. Jones, J. Holt, S. Wong, D. Keith, W. Levin, S. Stuart, J. Udove, A. Ullrich and a. et (1989). "Studies of the HER-2/neu proto-oncogene in human breast and ovarian cancer." Science 244(4905): 707-712.
  + Sledge, G.W. u. a., 2014. Past, present, and future challenges in breast cancer treatment. Journal of clinical oncology???: official journal of the American Society of Clinical Oncology, 32(19), S.1979-1986.
  + Stratton, M. R., P. J. Campbell and P. A. Futreal (2009). "The cancer genome." Nature 458(7239): 719-724.
  + Xu, J., Y. Chen and O. I. Olopade (2010). "MYC and Breast Cancer." Genes & cancer 1(6): 629-640.

