---
title: "Identification of SSTs_report"
author: "Lisa Marie Milchsack"
date: "10 Juni 2019"
output:
  word_document: default
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Installing required packages
```{r}
install.packages("reshape")
install.packages("wesanderson")
install.packages("tidyverse")
install.packages("factoextra")
install.packages("data.table")
library(tidyverse)
library(cluster)
library(factoextra)
library("reshape")
library("wesanderson")
library(ddata.table)
```

# Abstract
# Introduction
Breast Cancer is the most praevalent tumor disease in women and the most dangerous in blabla...
# Main

## Data clean up
To gain an overview of general data distribution we first had to extract the breast cancer data from the larger dataset containing all kinds of tumor diseases. After loading the data we therefore identified 28 cell lines harvesting breast cancer.
```{r}
#load data
allDepMapData = readRDS("C:/Users/lisa-/Desktop/Studium/4. FS/Bioinfo/DepMap19Q1_allData.RDS")

#finding all breast cancer cell lines
BCCL_Numbers <- which(allDepMapData$annotation[4]== "Breast Cancer")
BCCL_Annotation <- subset(allDepMapData$annotation, Primary.Disease == "Breast Cancer")
```
From these cell lines we got expression values, copynumbers, and knockdown scores in cell viability and probability of cell survival as described in the introduction. To make data more clear, we constructed dataframes for every *sort of data* and ordered the genes alphabetically. 
```{r}
#summary(BCCL_Annotation)
# copy expression matrix to new dataframes
df1 <- allDepMapData$expression
df2 <- allDepMapData$copynumber
df3 <- allDepMapData$kd.ceres
df4 <- allDepMapData$kd.prob
#change column names to numbers for easier handling
names(df1) <- c(1:544)
names(df2) <- c(1:544)
names(df3) <- c(1:544)
names(df4) <- c(1:544)
#extract BCCL as dataframe
BCCL_Expression <- as.data.frame( df1[, c(BCCL_Numbers)])
BCCl_Copynumber <- as.data.frame( df2[, c(BCCL_Numbers)])
BCCL_kd.ceres <- as.data.frame( df3[, c(BCCL_Numbers)])
BCCL_kd.prob <- as.data.frame( df4[, c(BCCL_Numbers)])
dim(BCCL_Expression)
dim(BCCl_Copynumber)
dim(BCCL_kd.ceres)
dim(BCCL_kd.prob)
#reorder rows alphabetically
BCCL_Expression <- BCCL_Expression[order(rownames(BCCL_Expression)), ]
BCCl_Copynumber <- BCCl_Copynumber[order(rownames(BCCl_Copynumber)), ]
BCCL_kd.ceres <- BCCL_kd.ceres[order(rownames(BCCL_kd.ceres)), ]
BCCL_kd.prob <- BCCL_kd.prob[order(rownames(BCCL_kd.prob)), ]
#subset Mutation matrix in BCCL
BCCL_Mutation <- allDepMapData$mutation[c(BCCL_Numbers)]
```
As next step we made some experiments, to get a feeling for data distribution. 
We made a heatmap of expression values, compared single genes for knockdown and copynumber scores and found relatively equally distibuted expression values and CERES Scores. We also tried to gain a first look on driver mutations, known from literature.
*muss noch sch?n gemacht werden :)*
```{r echo=TRUE}
tBCCL_Expression <- t(BCCL_Expression)
boxplot(tBCCL_Expression[, c("MYC", "PTEN", "TP53", "PIK3CA", "GATA3", "BRCA1", "BRCA2", "RB1", "GANAB", "PRKCSH", "RNF43")], xlab = "Suggested driver mutations", ylab ="Transcripts per million")
```
We already discarded some of this genes, mostly because they are known as tumor suppressor genes. In our approach we looked for targets, which show similar characteristics in cell viability after a knockdown. A knockdown of a tumor supressor gene, even if it is mutated, will rarely have a negative effect on cell viability. This makes genes associated with tumor supressor genes useless for an inhibitory drug and therefore useless for our analysis. 

### Generation of the mutImpact matrix

In order to gain an overview over the effects on viability of each mutation present in one cell line the mutImpact matrix was generated.

Therefore, the BCCL_kd.ceres matrix containing CERES scores for all genes in breast cancer cell lines was used as a template and the cell line IDs were added as column names creating a pre_mutImpact matrix. An empty matrix was generated comprising 17634 rows and 28 columns matching the number of genes per cell line and the number of breast cancer cell lines, respectively. 

Subsequently, CERES scores of genes which were not mutated in a given cell line were replaced with "NA" by implementing an if statement. This statement included the enquiry whether the gene ID is present in the list of mutated genes of a considered cell line as and in case the condition was met the CERES score was maintained. If "FALSE" was returned the CERES score of the gene was replaced with "NA" for the considered cell line.

```{r, warning=FALSE}
#Generate pre_mutImpact matrix containing all CERES values and with IDs as colnames
pre_mutImpact <- BCCL_kd.ceres
colnames(pre_mutImpact)<-tPatients_ID

#generate empty mutImpact matrix
mutImpact <- matrix(, nrow = 17634, ncol = 28)
colnames(mutImpact)<-colnames(pre_mutImpact)
rownames(mutImpact)<-rownames(pre_mutImpact)

#fill mutImpact matrix with values
for (j in 1:ncol(pre_mutImpact)){
  lineID <- colnames(pre_mutImpact)[j] #select a column-name = cell line
  for (i in 1:nrow(pre_mutImpact)){
    GOI <- rownames(pre_mutImpact)[i] #select a gene
    if (GOI %in% BCCL_Mutation[[lineID]]$Hugo_Symbol){
      mutImpact[i, j] <- pre_mutImpact[i, j]
    } else {
      mutImpact[i, j] <- NA
    }#replace CERES value with NA in case the gene is not mutated
  }
}

#have a look at the mutImpact matrtix
head(mutImpact)
```

### Identification of driver mutations using k means clustering of CERES scores 

In order to verify our selection of driver mutations from literature research, k means clustering of CERES scores was performed.

```{r kmeans ceres}

#Loading mutImpact matrix
pre_mutImpact <- BCCL_kd.ceres
colnames(pre_mutImpact)<-tPatients_ID
mutImpact <- matrix( , nrow = 17634, ncol = 28)
colnames(mutImpact)<-colnames(pre_mutImpact)
rownames(mutImpact)<-rownames(pre_mutImpact)
for (j in 1:ncol(pre_mutImpact)){
  lineID <- colnames(pre_mutImpact)[j] #select a column-name aka cell line
  for (i in 1:nrow(pre_mutImpact)){
    GOI <- rownames(pre_mutImpact)[i] #select a gene
    if (GOI %in% BCCL_Mutation[[lineID]]$Hugo_Symbol){
      mutImpact[i, j] <- pre_mutImpact[i, j]
    } else {
      mutImpact[i, j] <- NA
    }#replace CERES value with NA in case the gene is not mutated
  }
}
```

K means clustering was performed with all genes mutated at least once out of all 28 cell line samples and whose CERES score is equal to or lower than zero. For this, all genes with only NA values, hence not one mutation in any cell sample, were removed. A new dataframe `BCCL_kd.ceres_2`was generated containing all 28 CERES scores for each gene, with gene names in the first column. Gene names in the first column of the data frame `BCCL_kd.ceres_2`were compared to the rownames of `mutImpact_c` to generate the BCCL_kd.ceres_3 dataframe containing CERES scores for all breast cell cancer lines for all genes mutated at least once. Subsequently, the mean CERES score for each gene was computed using the rowmeans function and saved in the last column. For this, the column `rownameskdc2`had to be removed. Finally, all genes with CERES scores > 0 were deleted. The final BCCL_kd.ceres_3 dataframe now contains 4934 genes mutated at least once in the 28 breast cancer cell lines and with CERES scores equal to or below 0. 

```{r}
# selecting only genes mutated at least once and with Ceres >= 0
mutImpact_c = mutImpact[rowSums(is.na(mutImpact)) != ncol(mutImpact),]# remove all genes withall NA values
rownamesmutImpc = rownames(mutImpact_c)
mutImpact_c = cbind(rownamesmutImpc, mutImpact_c[,2:ncol(mutImpact_c)]) # insert new column with row names
dim(mutImpact_c) # check gene reduction 
rownameskdc2 = rownames(BCCL_kd.ceres) 

BCCL_kd.ceres_2 = cbind(rownameskdc2, BCCL_kd.ceres[,2:ncol(BCCL_kd.ceres)]) # insert new column with row names
BCCL_kd.ceres_3 = BCCL_kd.ceres_2[BCCL_kd.ceres_2[,"rownameskdc2"] %in%  mutImpact_c[,"rownamesmutImpc"],][,-c(1)]
BCCL_kd.ceres_3 = cbind(BCCL_kd.ceres_3, rowMeans(BCCL_kd.ceres_3))[rowMeans(cbind(BCCL_kd.ceres_3, rowMeans(BCCL_kd.ceres_3)))<= 0,] # deletion of genes with CERES > 0
```

In preparation of k means clustering, the column containing average CERES scores for each gene was removed (new dataframe `BCCL_kd.ceresKS`) and the optimal number of k clusters identified. For each column, so cell samples, of the dataframe the data values were scaled. For cluster numbers between 2 und 15 the within sum of squares for each cell sample was calculated and stored as a seperate dataframe. *need to add comment on why set.seed and sum(kmeans)*

```{r}
#determining optimal cluster number k
BCCL_kd.ceresKS = BCCL_kd.ceres_3[,-c(28)] # remove column of average CERES value column 

CERES_Optimal_K <- function(BCCL_kd.ceresKS, specifier) {
  output <- lapply(1:ncol(BCCL_kd.ceresKS), function(a){
   df <- scale(BCCL_kd.ceresKS[,a]) # pick one column of input data and scale 
   wss <-(nrow(df-1))*sum(apply(df,2,var)) #compute wss
   for (i in 2:15){ # for k between 2 and 15
     set.seed(1234)
     wss[i] <- sum(kmeans(df, centers = i)$withinss)} 
   return(wss)
  })
names (output) <- colnames(BCCL_kd.ceresKS) # rename the output 
return(output)
}

BCCL_kd.ceres_optKS <- CERES_Optimal_K(BCCL_kd.ceresKS, "CERES Optimal Clusters k") 
```

To enable the plotting of within sum square (WSS) values for clusters from 2 to 15 for each breast cancer cell, each vector was individually picked and formatted into a dataframe. Cell sample name was then added as a label in a new column "Cell_Sample" and the cluster numbers from 1 to 15 in the column "OptimalK".
The output of this lapply function (`optimalKprocessedData`), a list of 28 dataframes, was then combined into one and columns renamed accordingly. The ggplot function was then used to plot all data stored in `optimalKprocessedData` in one plot. 

```{r}
# plotting wss function 
optimalKprocessedData <- lapply(seq_along(BCCL_kd.ceres_optKS), function(a){
  dtPicker <- as.data.frame(BCCL_kd.ceres_optKS[[a]]) # one vector picked and formatted into dataframe
  dtPicker$Cell_Sample <- names(BCCL_kd.ceres_optKS)[a] #sample added as label
  dtPicker$OptimalK <- 1:nrow(dtPicker) 
  return(dtPicker)
})

optimalKprocessedData <- as.data.frame(rbindlist(optimalKprocessedData)) # output into dataframe
colnames(optimalKprocessedData) <- c("WSS", "Sample", "OptimalK")

# using ggplot to plot output 
ggplot(data = optimalKprocessedData, aes(x=OptimalK, y=WSS)) +
  geom_line(aes(color=Cell_Sample)) +
  labs(title = 'Optimal number of clusters k', x = 'Number of clusters', y = 'WSS') +
  theme_minimal() +
           theme(legend.position ='bottom',
                  plot.title = element_text(hjust = 0.5),
                  axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
                  legend.title= element_blank(),
                  axis.title.x = element_blank(),
                  strip.text.y = element_text(angle = 0))
```
From this plot it is evident that the optimal cluster number, when applying the elbow method, lies between 2 and 4. To verify this result and to determine the optimal cluster number, an alternative plotting method calculating the average WSS for cluster numbers between 2 and 15 for all 28 cell samples was performed. 

```{r} 
# Verification of optimal number of clusters k 

km_CERES= kmeans(x = BCCL_kd.ceres_3, centers = 2, nstart = 10)
table(km_CERES$cluster)
wss = sapply(2:10, function(k) {
    kmeans(x = BCCL_kd.ceres_3, centers = k)$tot.withinss
})
plot(2:15, wss, type = "b", pch = 19, xlab = "Number of clusters K", ylab = "Total within-clusters sum of squares") 
```

The optimal cluster number k was identified to be 4. Thus k means clustering of the data in BCCL_kd.ceres_3 was performed with 10 iterations. The following cluster plot was generated.

```{r}
km_CERES= kmeans(x = BCCL_kd.ceres_3, centers = 4, nstart = 10)
table(km_CERES$cluster)
fviz_cluster(km_CERES, data=BCCL_kd.ceres_3, labelsize = 6) # plotting clusters
```

In order to verify our selection of driver mutations from literature, the cluster number of each driver mutation was identified. All selected driver mutations from literature,"ERBB2", "MYCBP", "PARP10" and "PIK3CA" were colocalized in cluster 3, hence with similar CERES scores, with the exception of "CCND" and "ERBBIP". While "CCND" was removed in the filtering process and no longer found in`BCCL_kd.ceres_3`, "ERBB2IP" was found in cluster 2. For these reasons the mentioned two mutations were excluded from further analysis, to leave only "ERBB2", "MYCBP", "PARP10" and "PIK3CA" as selected driver mutations for further analysis. 

``` {r}
km_CERES$cluster["ERBB2"] #obtaining cluster number for each driver mutation from literature 
km_CERES$cluster["ERBB2IP"]
km_CERES$cluster["MYCBP"]
km_CERES$cluster["PARP10"]
km_CERES$cluster["PIK3CA"] 
```

Since our approach defined SSTs as genes expected to interact synergistcally with the corresponding driver mutation in promoting cell viability, similar CERES scores were expected. Thus all potential SSTs candidates were expected to also be found in cluster 3. A dataframe `data_clus_3`was subsequently generated to contain all 1148 genes colocalized with driver mutations in cluster 3. 

```{r}
data_cluster = km_CERES$cluster
rownames(data_cluster) = rownames(BCCL_kd.ceres_3)
data_clus_3 = BCCL_kd.ceres_3[data_cluster == 3,] #dataframe with all 1148 genes in same cluster as driver mutations 
```

A further dataframe `data_clus_3e` was subsequently generated labelling the four driver mutations in a separate column, by implementing an "IF" loop. If the rowname of `data_clus_3e`was found in a previously created vector containing driver mutations names (`drivermut`), it was labelled as "driver mutation".Otherwise genes were labelled as "no driver mutation".

```{r Labeling driver mutations}

drivermut =  c("ERBB2","MYCBP", "PARP10", "PIK3CA") # create vector with driver mutation names

data_clus_3e = data_clus_3
data_clus_3e["Driver mutation"] <- sapply(1:nrow(data_clus_3), function(j){
     if(rownames(data_clus_3e)[j] %in% drivermut){
         data_clus_3e[j,1] = "driver mutation"
     } else {
         data_clus_3e[j,1] = "no driver mutation"
     }
  }) # labeling driver mutations with "driver mutation" in data_clus_3e 
```

### Data visualisation of CERES and TPM values for the four selected driver mutations 

CERES scores and expression as TPM values for the selected 4 driver mutations were visualised as box and whisker plots. Following the generation of the `GOI_X` dataframe containing either CERES or TPM values for the four mutations, the data was reshaped to contain two columns. One column being "variable" with the names of driver mutations, the other "value" with the corresponding CERES or TPM value. The ggplot function, part of the ggplot2 package, was used to plot the following box an whisker plots. 

```{r data visualisation, fig.align = center, fig.cap= Box and Whisker plots for CERES and TPM values}

# CERES_boxplot
GOI= BCCL_kd.ceres[c("ERBB2","MYCBP", "PARP10", "PIK3CA"),]
CERES_driver_mut= melt(GOI)
CERES_driver_mut$variable=rep(c("ERBB2","MYCBP", "PARP10", "PIK3CA"), ncol(GOI))

CERES_boxplot = ggplot(CERES_driver_mut, aes(x = variable, y = value)) +
       geom_boxplot(aes(fill=variable), outlier.alpha = 0.7,
                     outlier.colour = "grey", outlier.shape = 20, outlier.size = 2) +
        labs(title = 'CERES scores of selected driver mutations', x = 'Selected driver   mutations', y = 'CERES scores') +
            theme_minimal() +
            geom_jitter(width = 0.2) +
            scale_fill_manual(values=wes_palette(n=4, name="Royal2")) +
            theme(legend.position ='none',
                  plot.title = element_text(hjust = 0.4),
                  axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
                  legend.title= element_blank(),
                  axis.title.x = element_blank(),
                  strip.text.y = element_text(angle = 0))
CERES_boxplot

  
#Expression_boxplot
GOI_Exp= BCCL_Expression[c("ERBB2","MYCBP", "PARP10", "PIK3CA"),]
Expression_driver_mut= melt(GOI_Exp)
Expression_driver_mut$variable=rep(c("ERBB2","MYCBP", "PARP10", "PIK3CA"), ncol(GOI_Exp))

Expression_boxplot = ggplot(Expression_driver_mut, aes(x = variable, y = value)) +
       geom_boxplot(aes(fill=variable), outlier.alpha = 0.7,
                     outlier.colour = "grey", outlier.shape = 20, outlier.size = 2) +
        labs(title = 'Transcripts per million (TPM) of selected driver mutations', x = 'Selected driver mutations', y = 'Transcripts per million (TPM)') +
            theme_minimal() +
            geom_jitter(width = 0.2) +
            scale_fill_manual(values=wes_palette(n=4, name="Royal2")) +
            theme(legend.position ='none',
                  plot.title = element_text(hjust = 0.4),
                  axis.text.x = element_text(angle = 0, vjust = 0, hjust=0.5),
                  legend.title= element_blank(),
                  axis.title.x = element_blank(),
                  strip.text.y = element_text(angle = 0))
Expression_boxplot
```

The box and whisker plot of CERES scores reveals highest essentiallity of the MYCBP driver mutation for cell survival, through the lowest average CERES scores. This is followed by PIK3CA and PARP10 mutations. While ERBB2 has the highest average CERES scores and hence lowest impact on cell proliferation, this mutation exhibits the largest spread of values across 28 breast cell cancer lines, reaching the overall minimum value of -1. The interquartile range of CERES scores for both MYCBP and PARP10, are lowest, indicating a consistent impact of gene knockouts on cell sample survival.To be noted also is the large interquartile range of the PIK3CA mutation, with data points found in two clusters, one around -0.15 and the other bweetn -0.5 and -0.9. 

While the ERBB2 driver mutation was found to have on average the lowest essentiallity for cell survival, average TPM values are shown to be highest, suggesting overexpression. Once again TPM values for this mutation have the largest spread, reaching a maximum over 11.5, implying greatest variation overall in data for the ERBB2 driver mutation. Like for the CERES scores, both MYCBP and PIK3CA have a small interquartile range, while ranges for PARP10 are markedly larger. Further, it is interesting to note despite two CERES score data clusters for PIK3CA, TPM values show little variation around the mean. 

### Spotting genetic interactions: the Wilcoxon test

Genetic interactions of driver mutations with other genes were examined based on a Wilcoxon signed rank test. As SSTs are expected to interact synergistcally with the corresponding driver mutation in promoting cell viability similar CERES scores are suggested to infer the presence of gene interactions. Thus, high p-values are anticipated for such cooperating gene pairs when performing the Wilcoxon signed rank test. The Wilcoxon signed rank test was chosed rather than a t-test due to non-normal distribution of the data and the requirement of a paired test to compare the data of two genes per cell line. Asuming that the ranks of the CERES scores of the driver mutation and their SSTs are equal SST candidates were chosen by the means of the highst p-values (accepting the H0 hypothesis).

For the purpose of conducting the Wilcoxon test the data from which the CERES scores for the test are taken was prepared. Therefore, a vector containg the identified driver mutations was generated. Furthermore, a reduced mutImpact matrix `mutImpact_r` was created from `mutImpact`which only includ genes which are mutated and do not have `NA`values only. Based on `mutImpact_r`the `BCCL_kd.ceres` matrix was reduced resutling in the `mutImpact_kd.ceres` matrix containing the CERES scores of all genes in all cell lines if the gene is mutated in one cell line at minimum. 

```{r}
#preparation of the data
driver_mut <- c("ERBB2","MYCBP", "PARP10", "PIK3CA") #enter driver mutations
mutImpact_r <- mutImpact[rowSums(is.na(mutImpact)) != ncol(mutImpact), ] #_r=reduced: get rid of all the ONLY NA rows (this will save computation)
mutImpact_kd.ceres <- BCCL_kd.ceres[rownames(BCCL_kd.ceres) %in% rownames(mutImpact_r),] # create matrix containing CERES scores of genes which are mutated once at minimum
colnames(mutImpact_kd.ceres) <- tPatients_ID
```

A Wilcoxon signed rank test was performed for every driver mutation with all other mutated genes and the data was stored in a list comprising one data frame with the obtained p-values for each driver mutation. 

Thereupon, a loop was installed generating the output data frame for each driver mutation. At first the driver mutation to be examined was selected and the corresponding CERES values retrieved from `mutImpact_kd.ceres` being saved in the temporary variable `driverMutData`. Consequently, a reference gene was chosen and the CERES scores of the reference gene was stored in another temporary vector `refGeneData`. In case the selected reference gene was not the driver mutation itself the Wilcoxon test was performed. The p-value of each gene pair was saved in the data frame of the considered driver mutation.

```{r}
#performance of the Wilcoxon test
testData <- lapply(seq_along(driver_mut), function(a) {
  driverMutPicker <- driver_mut[a] #pick a driver mutation
  driverMutData <- mutImpact_kd.ceres[driverMutPicker,] #get CERES scores of driver mutation
  
  outputData <- sapply(1:nrow(mutImpact_kd.ceres), function(b) {
    refGeneData <- mutImpact_kd.ceres[b,] #get CERES scores of reference gene (potential SST)
    
    if (rownames(refGeneData) != driverMutPicker) {
      out <- wilcox.test(as.numeric(driverMutData), as.numeric(refGeneData), paired = TRUE)$p.value #get p-value of wilcoxon signed-rank test
      out <- as.data.frame(out, rownames(mutImpact_r)[b]) 
      return(out)
    }
  })
  test = do.call(rbind, outputData)
  rownames(test) <- rownames(mutImpact_r)[which(rownames(mutImpact_r) != driverMutPicker)]
  return(test)
})
names(testData) <- driver_mut

lapply(testData, function(a) head(a)) #look at the data
```

As the null hypothesis claims that the CEREs scores of the driver mutation and the reference gene is are equal, low p-values indicate that there is no relation between the CERES scores of the driver mutation and the reference gene whereas high p-values may allude to genetic interaction of the driver mutation with an SST.
The obtained p-values were distributed as shown below. Most strinkingly, the first quantile was set at a p-value of 0.0 for each driver mutation indicating that there are many genes with CERES scores which are not relatable to the CERES scores of the driver mutations. However, the maximum p-value of each test constituted 1.0 suggesting that there are also genes with similar CERES scores as the driver mutations which are supposed to be the SSTs. 

```{r}
#get summary of distribution
summary(testData$ERBB2)
summary(testData$MYCBP)
summary(testData$PARP10)
summary(testData$PIK3CA)
```

Based on the results of the Wilcoxon test potential SSTs were chosen by means of the highest p-values. Thus, seperate `SST_cand_X` data frames were generated for each driver mutation using the `testData`data frames. Subsequently, those data frames were filtered selecting the reference genes which were found to have the most similar CERES scores as the driver mutation indicated by high p-values. In this course, the rownames of the data frames had to be transferred to an extra column before selection and transferred back afterwards as otherwise the rownames would have been lost during the filtering process.

```{r}
#select 15 most promising SST candidates based on highest p-values - libraries needed: dplyr, tibble (included in "tidyverse")

SST_cand_ERBB2 <- as.data.frame(testData$ERBB2, col.names = names(testData$ERBB2)) #create new data frame containing testData for ERBB2
SST_cand_MYCBP <- as.data.frame(testData$MYCBP, col.names = names(testData$MYCBP))
SST_cand_PARP10 <- as.data.frame(testData$PARP10, col.names = names(testData$PARP10))
SST_cand_PIK3CA <- as.data.frame(testData$PIK3CA, col.names = names(testData$PIK3CA))

names(SST_cand_ERBB2) = "ERBB2" #rename column
names(SST_cand_MYCBP) = "MYCBP"
names(SST_cand_PARP10) = "PARP10"
names(SST_cand_PIK3CA) = "PIK3CA"

SST_cand_ERBB2 <- SST_cand_ERBB2 %>%rownames_to_column() %>% top_n(15, ERBB2) %>% column_to_rownames() #select 15 genes with highest p-value
SST_cand_MYCBP <- SST_cand_MYCBP %>% rownames_to_column() %>% top_n(15, MYCBP) %>% column_to_rownames()
SST_cand_PARP10 <- SST_cand_PARP10 %>% rownames_to_column() %>% top_n(15, PARP10) %>% column_to_rownames()
SST_cand_PIK3CA <- SST_cand_PIK3CA %>% rownames_to_column() %>% top_n(15, PIK3CA) %>% column_to_rownames()

#have a look at the SST candidates
view(SST_cand_ERBB2)
view(SST_cand_MYCBP)
view(SST_cand_PARP10)
view(SST_cand_PIK3CA)
```

## Verification of SST candidates by assigned k means cluster number 

After selection of the SST candidates stored in `SST_cand_x`,loops were installed to verify the coexistance of SST candidates and driver mutations in the same k means cluster. An assignment to the same cluster would confirm a possible cooperation of gene pairs due to similar CERES scores. For this, new dataframes were created  before a separate loop was installed for each driver mutation. By comparing each rowname of the `SST_cand_X` dataframes to all possible  `data_clus_3e` rownames, a coexistance of genes in the 3rd k means cluster was identified, leading to the labelling of `SST X`  in a new separate column. Otherwise no match lead to the `No SST`entry. In order to combine all four dataframes with the `rbind`command the first columns were all renamed to "p_values". FInally all confirmed SSTs were ordered alphabetically, with no gene identified twice for a different driver mutation. 

```{r}
SST_ERBB2 <- SST_cand_ERBB2 #creating new dataframes
SST_MYCBP <- SST_cand_MYCBP
SST_PARP10 <- SST_cand_PARP10
SST_PIK3CA <- SST_cand_PIK3CA

#labelling of SST candidates with "SST" or "No SST" depending on if in k means cluster 3 or not

#PARP10 candidates
SST_PARP10["SST Cluster Check"] <- sapply(1:nrow(SST_cand_PARP10), function(a){
  if (rownames(SST_cand_PARP10) %in% rownames(data_clus_3e)) {
      SST_PARP10[a,1] ="SST PARP10"
  }else{
     SST_PARP10[a,1] = "No SST"
  }
})
SST_PARP10 <- SST_PARP10 %>% rename(p_values=PARP10)

#ERBB2 candidates
SST_ERBB2["SST Cluster Check"] <- sapply(1:nrow(SST_cand_ERBB2), function(a){
  if (rownames(SST_cand_ERBB2) %in% rownames(data_clus_3e)) {
      SST_ERBB2[a,1] ="SST ERBB2"
  }else{
     SST_PARP10[a,1] = "No SST"
  }
})
SST_ERBB2 <- SST_ERBB2 %>% rename(p_values= ERBB2)

#MYCBP candidates
SST_MYCBP["SST Cluster Check"] <- sapply(1:nrow(SST_cand_MYCBP), function(a){
  if (rownames(SST_cand_MYCBP) %in% rownames(data_clus_3e)) {
      SST_MYCBP[a,1] ="SST MYCBP"
  }else{
     SST_MYCBP[a,1] = "No SST"
  }
})
SST_MYCBP <- SST_MYCBP %>% rename(p_values= MYCBP)

#PIK3CA candidates
SST_PIK3CA["SST Cluster Check"] <- sapply(1:nrow(SST_cand_PIK3CA), function(a){
  if (rownames(SST_cand_PIK3CA) %in% rownames(data_clus_3e)) {
      SST_PIK3CA[a,1] ="SST PIK3CA"
  }else{
     SST_PIK3CA[a,1] = "No SST"
  }
})
SST_PIK3CA <- SST_PIK3CA %>% rename(p_values= PIK3CA)

#All approved SSTs in one dataframe with driver mutation label and p-value
SSTs <-  do.call("rbind", list(SST_ERBB2, SST_MYCBP, SST_PARP10, SST_PIK3CA)) 
SSTs <- SSTs[order(rownames(SSTs)),] # reorder in alphabetical order 

#no SSTs the same for different driver mutations 
```

### Regression analysis to predict ceres scores of driver mutation